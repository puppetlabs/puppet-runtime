diff --exclude-from=exclude -N -u -r nsalibselinux/include/selinux/av_permissions.h libselinux-1.33.4/include/selinux/av_permissions.h
--- nsalibselinux/include/selinux/av_permissions.h	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/include/selinux/av_permissions.h	2010-07-19 19:36:18.000000000 +0200
@@ -290,12 +290,16 @@
 #define NODE__RAWIP_RECV                          0x00000010UL
 #define NODE__RAWIP_SEND                          0x00000020UL
 #define NODE__ENFORCE_DEST                        0x00000040UL
+#define NODE__DCCP_RECV                           0x00000080UL
+#define NODE__DCCP_SEND                           0x00000100UL
 #define NETIF__TCP_RECV                           0x00000001UL
 #define NETIF__TCP_SEND                           0x00000002UL
 #define NETIF__UDP_RECV                           0x00000004UL
 #define NETIF__UDP_SEND                           0x00000008UL
 #define NETIF__RAWIP_RECV                         0x00000010UL
 #define NETIF__RAWIP_SEND                         0x00000020UL
+#define NETIF__DCCP_RECV                          0x00000040UL
+#define NETIF__DCCP_SEND                          0x00000080UL
 #define NETLINK_SOCKET__IOCTL                     0x00000001UL
 #define NETLINK_SOCKET__READ                      0x00000002UL
 #define NETLINK_SOCKET__WRITE                     0x00000004UL
@@ -837,6 +841,8 @@
 #define NSCD__SHMEMPWD                            0x00000020UL
 #define NSCD__SHMEMGRP                            0x00000040UL
 #define NSCD__SHMEMHOST                           0x00000080UL
+#define NSCD__GETSERV                             0x00000100UL
+#define NSCD__SHMEMSERV                           0x00000200UL
 #define ASSOCIATION__SENDTO                       0x00000001UL
 #define ASSOCIATION__RECVFROM                     0x00000002UL
 #define ASSOCIATION__SETCONTEXT                   0x00000004UL
@@ -888,6 +894,8 @@
 #define PACKET__SEND                              0x00000001UL
 #define PACKET__RECV                              0x00000002UL
 #define PACKET__RELABELTO                         0x00000004UL
+#define PACKET__FLOW_IN                           0x00000008UL
+#define PACKET__FLOW_OUT                          0x00000010UL
 #define KEY__VIEW                                 0x00000001UL
 #define KEY__READ                                 0x00000002UL
 #define KEY__WRITE                                0x00000004UL
@@ -897,3 +905,28 @@
 #define KEY__CREATE                               0x00000040UL
 #define CONTEXT__TRANSLATE                        0x00000001UL
 #define CONTEXT__CONTAINS                         0x00000002UL
+#define DCCP_SOCKET__IOCTL                        0x00000001UL
+#define DCCP_SOCKET__READ                         0x00000002UL
+#define DCCP_SOCKET__WRITE                        0x00000004UL
+#define DCCP_SOCKET__CREATE                       0x00000008UL
+#define DCCP_SOCKET__GETATTR                      0x00000010UL
+#define DCCP_SOCKET__SETATTR                      0x00000020UL
+#define DCCP_SOCKET__LOCK                         0x00000040UL
+#define DCCP_SOCKET__RELABELFROM                  0x00000080UL
+#define DCCP_SOCKET__RELABELTO                    0x00000100UL
+#define DCCP_SOCKET__APPEND                       0x00000200UL
+#define DCCP_SOCKET__BIND                         0x00000400UL
+#define DCCP_SOCKET__CONNECT                      0x00000800UL
+#define DCCP_SOCKET__LISTEN                       0x00001000UL
+#define DCCP_SOCKET__ACCEPT                       0x00002000UL
+#define DCCP_SOCKET__GETOPT                       0x00004000UL
+#define DCCP_SOCKET__SETOPT                       0x00008000UL
+#define DCCP_SOCKET__SHUTDOWN                     0x00010000UL
+#define DCCP_SOCKET__RECVFROM                     0x00020000UL
+#define DCCP_SOCKET__SENDTO                       0x00040000UL
+#define DCCP_SOCKET__RECV_MSG                     0x00080000UL
+#define DCCP_SOCKET__SEND_MSG                     0x00100000UL
+#define DCCP_SOCKET__NAME_BIND                    0x00200000UL
+#define DCCP_SOCKET__NODE_BIND                    0x00400000UL
+#define DCCP_SOCKET__NAME_CONNECT                 0x00800000UL
+#define MEMPROTECT__MMAP_ZERO                     0x00000001UL
diff --exclude-from=exclude -N -u -r nsalibselinux/include/selinux/flask.h libselinux-1.33.4/include/selinux/flask.h
--- nsalibselinux/include/selinux/flask.h	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/include/selinux/flask.h	2010-07-19 19:36:18.000000000 +0200
@@ -64,6 +64,8 @@
 #define SECCLASS_PACKET                                  57
 #define SECCLASS_KEY                                     58
 #define SECCLASS_CONTEXT                                 59
+#define SECCLASS_DCCP_SOCKET                             60
+#define SECCLASS_MEMPROTECT                              61
 
 /*
  * Security identifier indices for initial entities
diff --exclude-from=exclude -N -u -r nsalibselinux/include/selinux/selinux.h libselinux-1.33.4/include/selinux/selinux.h
--- nsalibselinux/include/selinux/selinux.h	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/include/selinux/selinux.h	2010-07-19 19:37:35.000000000 +0200
@@ -405,6 +405,8 @@
 	extern const char *selinux_file_context_local_path(void);
 	extern const char *selinux_homedir_context_path(void);
 	extern const char *selinux_media_context_path(void);
+	extern const char *selinux_virtual_domain_context_path(void);
+	extern const char *selinux_virtual_image_context_path(void);
 	extern const char *selinux_contexts_path(void);
 	extern const char *selinux_securetty_types_path(void);
 	extern const char *selinux_booleans_path(void);
diff --exclude-from=exclude -N -u -r nsalibselinux/Makefile libselinux-1.33.4/Makefile
--- nsalibselinux/Makefile	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/Makefile	2010-07-19 19:36:18.000000000 +0200
@@ -2,9 +2,15 @@
 	$(MAKE) -C src 
 	$(MAKE) -C utils
 
+swigify: all
+	$(MAKE) -C src swigify
+
 pywrap: 
 	$(MAKE) -C src pywrap
 
+rubywrap: 
+	$(MAKE) -C src rubywrap
+
 install: 
 	$(MAKE) -C include install
 	$(MAKE) -C src install
@@ -14,6 +20,9 @@
 install-pywrap: 
 	$(MAKE) -C src install-pywrap 
 
+install-rubywrap: 
+	$(MAKE) -C src install-rubywrap 
+
 relabel: 
 	$(MAKE) -C src relabel
 
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_add_callback.3 libselinux-1.33.4/man/man3/avc_add_callback.3
--- nsalibselinux/man/man3/avc_add_callback.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_add_callback.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,31 +1,31 @@
 .\" Hey Emacs! This file is -*- nroff -*- source.
 .\"
-.\" Author: Eamon Walsh (ewalsh@epoch.ncsc.mil) 2004
-.TH "avc_add_callback" "3" "9 June 2004" "" "SE Linux API documentation"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2004
+.TH "avc_add_callback" "3" "9 June 2004" "" "SELinux API documentation"
 .SH "NAME"
-avc_add_callback \- additional event notification for userspace object managers.
+avc_add_callback \- additional event notification for SELinux userspace object managers.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/avc.h>
 .sp
-.BI "int avc_add_callback(int (*" callback ")(u_int32_t " event , 
+.BI "int avc_add_callback(int (*" callback ")(uint32_t " event , 
 .in +\w'int avc_add_callback(int (*callback)('u
 .BI "security_id_t " ssid ,
-.br
+
 .BI "security_id_t " tsid ,
-.br
+
 .BI "security_class_t " tclass ,
-.br
+
 .BI "access_vector_t " perms ,
-.br
+
 .BI "access_vector_t *" out_retained "),"
 .in
 .in +\w'int avc_add_callback('u
-.BI "u_int32_t " events ", security_id_t " ssid , 
-.br
+.BI "uint32_t " events ", security_id_t " ssid , 
+
 .BI "security_id_t " tsid ", security_class_t " tclass ,
-.br
+
 .BI "access_vector_t " perms ");"
 .in
 .SH "DESCRIPTION"
@@ -173,7 +173,7 @@
 .BR AVC_CALLBACK_RESET .
 
 .SH "AUTHOR"
-Eamon Walsh <ewalsh@epoch.ncsc.mil>
+Eamon Walsh <ewalsh@tycho.nsa.gov>
 
 .SH "SEE ALSO"
 .BR avc_init (3),
@@ -181,3 +181,4 @@
 .BR avc_context_to_sid (3),
 .BR avc_cache_stats (3),
 .BR security_compute_av (3)
+.BR selinux (8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_cache_stats.3 libselinux-1.33.4/man/man3/avc_cache_stats.3
--- nsalibselinux/man/man3/avc_cache_stats.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_cache_stats.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,12 +1,12 @@
 .\" Hey Emacs! This file is -*- nroff -*- source.
 .\"
-.\" Author: Eamon Walsh (ewalsh@epoch.ncsc.mil) 2004
-.TH "avc_cache_stats" "3" "27 May 2004" "" "SE Linux API documentation"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2004
+.TH "avc_cache_stats" "3" "27 May 2004" "" "SELinux API documentation"
 .SH "NAME"
-avc_cache_stats, avc_av_stats, avc_sid_stats \- obtain userspace AVC statistics.
+avc_cache_stats, avc_av_stats, avc_sid_stats \- obtain userspace SELinux AVC statistics.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/avc.h>
 .sp
 .BI "void avc_av_stats(void);"
@@ -89,10 +89,11 @@
 is made before the cache is flushed.
 
 .SH "AUTHOR"
-Eamon Walsh <ewalsh@epoch.ncsc.mil>
+Eamon Walsh <ewalsh@tycho.nsa.gov>
 
 .SH "SEE ALSO"
 .BR avc_init (3),
 .BR avc_has_perm (3),
 .BR avc_context_to_sid (3),
 .BR avc_add_callback (3)
+.BR selinux (8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_cleanup.3 libselinux-1.33.4/man/man3/avc_cleanup.3
--- nsalibselinux/man/man3/avc_cleanup.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_cleanup.3	2010-07-19 19:36:18.000000000 +0200
@@ -1 +1 @@
-.so man3/avc_init.3
+.so man3/avc_open.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_compute_create.3 libselinux-1.33.4/man/man3/avc_compute_create.3
--- nsalibselinux/man/man3/avc_compute_create.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_compute_create.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,68 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "avc_compute_create" "3" "30 Mar 2007" "" "SELinux API documentation"
+.SH "NAME"
+avc_compute_create, avc_compute_member \- obtain SELinux label for new object.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/avc.h>
+.sp
+.BI "int avc_compute_create(security_id_t " ssid ", security_id_t " tsid ,
+.in +\w'int avc_compute_create('u
+.BI "security_class_t " tclass ", security_id_t *" newsid ");"
+.sp
+.in
+.BI "int avc_compute_member(security_id_t " ssid ", security_id_t " tsid ,
+.in +\w'int avc_compute_member('u
+.BI "security_class_t " tclass ", security_id_t *" newsid ");"
+.in
+.SH "DESCRIPTION"
+.B avc_compute_create
+is used to compute a SID to use for labeling a new object in a particular class based on a SID pair.  This call is identical to
+.BR security_compute_create ,
+but does not require converting from userspace SID's to contexts and back again.
+
+.B avc_compute_member
+is used to compute a SID to use for labeling a polyinstantiated object instance of a particular class based on a SID pair.  This call is identical to
+.BR security_compute_member ,
+but does not require converting from userspace SID's to contexts and back again.
+
+These functions
+return a SID for the computed context in the memory referenced by
+.IR sid ,
+incrementing its reference count by 1.
+
+.SH "RETURN VALUE"
+On success, zero is returned.  On error, \-1 is returned and
+.I errno
+is set appropriately.
+
+.SH "ERRORS"
+.TP
+.B EINVAL
+The
+.I tclass
+and/or the security contexts referenced by
+.I ssid
+and
+.I tsid
+are not recognized by the currently loaded policy, or 
+.I tsid
+or
+.I ssid
+has a zero reference count and is invalid.
+
+.TP
+.B ENOMEM
+An attempt to allocate memory failed.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR avc_init (3),
+.BR avc_context_to_sid (3),
+.BR security_compute_create (3),
+.BR selinux (8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_compute_member.3 libselinux-1.33.4/man/man3/avc_compute_member.3
--- nsalibselinux/man/man3/avc_compute_member.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_compute_member.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/avc_compute_create.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_context_to_sid.3 libselinux-1.33.4/man/man3/avc_context_to_sid.3
--- nsalibselinux/man/man3/avc_context_to_sid.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_context_to_sid.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,12 +1,12 @@
 .\" Hey Emacs! This file is -*- nroff -*- source.
 .\"
-.\" Author: Eamon Walsh (ewalsh@epoch.ncsc.mil) 2004
-.TH "avc_context_to_sid" "3" "27 May 2004" "" "SE Linux API documentation"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2004
+.TH "avc_context_to_sid" "3" "27 May 2004" "" "SELinux API documentation"
 .SH "NAME"
-avc_context_to_sid, avc_sid_to_context, sidput, sidget \- obtain and manipulate security ID's.
+avc_context_to_sid, avc_sid_to_context, sidput, sidget, avc_get_initial_sid \- obtain and manipulate SELinux security ID's.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/avc.h>
 .sp
 .BI "int avc_context_to_sid(security_context_t " ctx ", security_id_t *" sid ");"
@@ -16,6 +16,9 @@
 .BI "int sidget(security_id_t " sid ");"
 .sp
 .BI "int sidput(security_id_t " sid ");"
+.sp
+.BI "int avc_get_initial_sid(const char *" name ", security_id_t *" sid ");"
+.sp
 .SH "DESCRIPTION"
 Security ID's (SID's) are reference-counted, opaque representations of security contexts.  
 
@@ -45,6 +48,10 @@
 by 1.  If the count ever reaches zero, the SID becomes
 invalid and must not be used any further.
 
+.B avc_get_initial_sid
+returns a SID for the kernel initial security identifier specified by 
+.I name
+
 .SH "RETURN VALUE"
 .B sidget
 and
@@ -79,7 +86,7 @@
 will be called on a SID when its object is destroyed.  Proper reference counting is necessary to ensure that SID's and associated cache entries are reclaimed from memory when no longer needed.
 
 .SH "AUTHOR"
-Eamon Walsh <ewalsh@epoch.ncsc.mil>
+Eamon Walsh <ewalsh@tycho.nsa.gov>
 
 .SH "SEE ALSO"
 .BR avc_init (3),
@@ -88,3 +95,4 @@
 .BR avc_add_callback (3),
 .BR getcon (3),
 .BR freecon (3)
+.BR selinux (8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_destroy.3 libselinux-1.33.4/man/man3/avc_destroy.3
--- nsalibselinux/man/man3/avc_destroy.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_destroy.3	2010-07-19 19:36:18.000000000 +0200
@@ -1 +1 @@
-.so man3/avc_init.3
+.so man3/avc_open.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_get_initial_context.3 libselinux-1.33.4/man/man3/avc_get_initial_context.3
--- nsalibselinux/man/man3/avc_get_initial_context.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_get_initial_context.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/avc_context_to_sid.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_has_perm.3 libselinux-1.33.4/man/man3/avc_has_perm.3
--- nsalibselinux/man/man3/avc_has_perm.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_has_perm.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,12 +1,12 @@
 .\" Hey Emacs! This file is -*- nroff -*- source.
 .\"
-.\" Author: Eamon Walsh (ewalsh@epoch.ncsc.mil) 2004
-.TH "avc_has_perm" "3" "27 May 2004" "" "SE Linux API documentation"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2004
+.TH "avc_has_perm" "3" "27 May 2004" "" "SELinux API documentation"
 .SH "NAME"
 avc_has_perm, avc_has_perm_noaudit, avc_audit, avc_entry_ref_init \- obtain and audit SELinux access decisions.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/avc.h>
 .sp
 .BI "void avc_entry_ref_init(struct avc_entry_ref *" aeref ");"
@@ -14,21 +14,21 @@
 .BI "int avc_has_perm(security_id_t " ssid ", security_id_t " tsid ,
 .in +\w'int avc_has_perm('u
 .BI "security_class_t " tclass ", access_vector_t " requested ,
-.br
+
 .BI "struct avc_entry_ref *" aeref ", void *" auditdata ");"
 .in
 .sp
 .BI "int avc_has_perm_noaudit(security_id_t " ssid ", security_id_t " tsid ,
 .in +\w'int avc_has_perm('u
 .BI "security_class_t " tclass ", access_vector_t " requested ,
-.br
+
 .BI "struct avc_entry_ref *" aeref ", struct av_decision *" avd ");"
 .in
 .sp
 .BI "void avc_audit(security_id_t " ssid ", security_id_t " tsid ,
 .in +\w'void avc_audit('u
 .BI "security_class_t " tclass ", access_vector_t " requested ,
-.br
+
 .BI "struct av_decision *" avd ", int " result ", void *" auditdata ");"
 .in
 .SH "DESCRIPTION"
@@ -144,7 +144,7 @@
 netlink by the policy.
 
 .SH "AUTHOR"
-Eamon Walsh <ewalsh@epoch.ncsc.mil>
+Eamon Walsh <ewalsh@tycho.nsa.gov>
 
 .SH "SEE ALSO"
 .BR avc_init (3),
@@ -152,3 +152,4 @@
 .BR avc_cache_stats (3),
 .BR avc_add_callback (3),
 .BR security_compute_av (3)
+.BR selinux(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_init.3 libselinux-1.33.4/man/man3/avc_init.3
--- nsalibselinux/man/man3/avc_init.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_init.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,50 +1,35 @@
 .\" Hey Emacs! This file is -*- nroff -*- source.
 .\"
-.\" Author: Eamon Walsh (ewalsh@epoch.ncsc.mil) 2004
-.TH "avc_init" "3" "27 May 2004" "" "SE Linux API documentation"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2004
+.TH "avc_init" "3" "27 May 2004" "" "SELinux API documentation"
 .SH "NAME"
-avc_init, avc_destroy, avc_reset, avc_cleanup \- userspace AVC setup and teardown.
+avc_init - legacy userspace SELinux AVC setup.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/avc.h>
 .sp
 .BI "int avc_init(const char *" msgprefix , 
 .in +\w'int avc_init('u
 .BI "const struct avc_memory_callback *" mem_callbacks ,
-.br
+
 .BI "const struct avc_log_callback *" log_callbacks ,
-.br
+
 .BI "const struct avc_thread_callback *" thread_callbacks ,
-.br
+
 .BI "const struct avc_lock_callback *" lock_callbacks ");"
-.in
-.sp
-.BI "void avc_destroy(void);"
-.sp
-.BI "int avc_reset(void);"
-.sp
-.BI "void avc_cleanup(void);"
 .SH "DESCRIPTION"
 .B avc_init
-initializes the userspace AVC and must be called before any other AVC operation can be performed.  A non-NULL
-.I msgprefix
-will be prepended to all audit messages produced by the userspace AVC.  The default is `uavc'.  The remaining arguments, if non-NULL, specify callbacks to be used by the userspace AVC.  See 
-.B CALLBACKS
-below.
+is deprecated; please use
+.BR avc_open (3)
+in conjunction with
+.BR selinux_set_callback (3)
+in all new code.
 
-.B avc_destroy
-destroys the userspace AVC, freeing all internal memory structures.  After this call has been made, 
 .B avc_init
-must be called again before any AVC operations can be performed.
-
-.B avc_reset
-flushes the userspace AVC, causing it to forget any cached access decisions.  The userspace AVC normally calls this function automatically when needed, see
-.B NETLINK NOTIFICATION
-below.
-
-.B avc_cleanup
-forces the userspace AVC to search for and free all unused SID's and any access decision entries that refer to them.  Normally, the userspace AVC lazily reclaims unused SID's.  
+initializes the userspace AVC and must be called before any other AVC operation can be performed.  A non-NULL
+.I msgprefix
+will be prepended to all audit messages produced by the userspace AVC.  The default is `uavc'.  The remaining arguments, if non-NULL, specify callbacks to be used by the userspace AVC.
 
 .SH "CALLBACKS"
 The userspace AVC can be directed how to perform memory allocation, logging, thread creation, and locking via callback functions passed to
@@ -201,11 +186,10 @@
 is called.
 
 .SH "AUTHOR"
-Eamon Walsh <ewalsh@epoch.ncsc.mil>
+Eamon Walsh <ewalsh@tycho.nsa.gov>
 
 .SH "SEE ALSO"
-.BR avc_has_perm (3),
-.BR avc_context_to_sid (3),
-.BR avc_cache_stats (3),
-.BR avc_add_callback (3),
-.BR security_compute_av (3)
+.BR avc_open (3),
+.BR selinux_set_callback (3),
+.BR selinux (8)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_open.3 libselinux-1.33.4/man/man3/avc_open.3
--- nsalibselinux/man/man3/avc_open.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_open.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,70 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2008
+.TH "avc_open" "3" "12 Jun 2008" "" "SELinux API documentation"
+.SH "NAME"
+avc_open, avc_destroy, avc_reset, avc_cleanup \- userspace SELinux AVC setup and teardown.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/avc.h>
+.sp
+.BI "int avc_open(struct selinux_opt *" options ", unsigned " nopt ");"
+.sp
+.BI "void avc_destroy(void);"
+.sp
+.BI "int avc_reset(void);"
+.sp
+.BI "void avc_cleanup(void);"
+.SH "DESCRIPTION"
+.B avc_open
+initializes the userspace AVC and must be called before any other AVC operation can be performed.
+
+.B avc_destroy
+destroys the userspace AVC, freeing all internal memory structures.  After this call has been made, 
+.B avc_open
+must be called again before any AVC operations can be performed.
+
+.B avc_reset
+flushes the userspace AVC, causing it to forget any cached access decisions.  The userspace AVC normally calls this function automatically when needed, see
+.B NETLINK NOTIFICATION
+below.
+
+.B avc_cleanup
+forces the userspace AVC to search for and free all unused SID's and any access decision entries that refer to them.  Normally, the userspace AVC lazily reclaims unused SID's.  
+
+.SH "OPTIONS"
+The userspace AVC obeys callbacks set via
+.BR selinux_set_callback (3),
+in particular the logging and audit callbacks.
+
+The options which may be passed to
+.B avc_open
+include the following:
+
+.TP
+.B AVC_OPT_SETENFORCE
+This option forces the userspace AVC into enforcing mode if the option value is non-NULL; permissive mode otherwise.  The system enforcing mode will be ignored.
+
+.SH "NETLINK NOTIFICATION"
+Beginning with version 2.6.4, the Linux kernel supports SELinux status change notification via netlink.  Two message types are currently implemented, indicating changes to the enforcing mode and to the loaded policy in the kernel, respectively.  The userspace AVC listens for these messages and takes the appropriate action, modifying the behavior of
+.BR avc_has_perm (3)
+to reflect the current enforcing mode and flushing the cache on receipt of a policy load notification.  Audit messages are produced when netlink notifications are processed.
+
+.SH "RETURN VALUE"
+Functions with a return value return zero on success.  On error, \-1 is returned and
+.I errno
+is set appropriately.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selinux (8),
+.BR avc_has_perm (3),
+.BR avc_context_to_sid (3),
+.BR avc_cache_stats (3),
+.BR avc_add_callback (3),
+.BR selinux_set_callback (3),
+.BR security_compute_av (3)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/avc_reset.3 libselinux-1.33.4/man/man3/avc_reset.3
--- nsalibselinux/man/man3/avc_reset.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/avc_reset.3	2010-07-19 19:36:18.000000000 +0200
@@ -1 +1 @@
-.so man3/avc_init.3
+.so man3/avc_open.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/context_new.3 libselinux-1.33.4/man/man3/context_new.3
--- nsalibselinux/man/man3/context_new.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/context_new.3	2010-07-19 19:36:18.000000000 +0200
@@ -4,27 +4,27 @@
 
 .SH "SYNOPSIS"
 .B #include <selinux/context.h>
-.br 
+
 .B "context_t context_new(const char *" context_str );
-.br 
+
 .B "const char * context_str(context_t " con );
-.br 
+
 .B "void context_free(context_t " con );
-.br 
+
 .B "const char * context_type_get(context_t " con );
-.br 
+
 .B "const char * context_range_get(context_t " con );
-.br 
+
 .B "const char * context_role_get(context_t " con );
-.br 
+
 .B "const char * context_user_get(context_t " con );
-.br 
+
 .B "const char * context_type_set(context_t " con ", const char* " type);
-.br 
+
 .B "const char * context_range_set(context_t " con ", const char* " range);
-.br 
+
 .B "const char * context_role_set(context_t " con ", const char* " role );
-.br 
+
 .B "const char * context_user_set(context_t " con ", const char* " user );
 
 .SH "DESCRIPTION"
@@ -56,3 +56,6 @@
 On success, zero is returned. On failure, -1 is returned and errno is
 set appropriately.
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/fgetfilecon.3 libselinux-1.33.4/man/man3/fgetfilecon.3
--- nsalibselinux/man/man3/fgetfilecon.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/fgetfilecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/getfilecon.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/freecon.3 libselinux-1.33.4/man/man3/freecon.3
--- nsalibselinux/man/man3/freecon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/freecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,11 +1,11 @@
-.TH "freecon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "freecon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-freecon, freeconary \- free memory associated with SE Linux security contexts.
+freecon, freeconary \- free memory associated with SELinux security contexts.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "void freecon(security_context_t "con );
-.br 
+
 .BI "void freeconary(security_context_t *" con );
 
 .SH "DESCRIPTION"
@@ -14,3 +14,12 @@
 
 .B freeconary
 frees the memory allocated for a context array.
+
+If
+.I con
+is NULL, no operation is performed.
+
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getcon.3 libselinux-1.33.4/man/man3/getcon.3
--- nsalibselinux/man/man3/getcon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/getcon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,21 +1,21 @@
-.TH "getcon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "getcon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-getcon, getprevcon, getpidcon \- get SE Linux security context of a process.
-.br
+getcon, getprevcon, getpidcon \- get SELinux security context of a process.
+
 getpeercon - get security context of a peer socket.
-.br
+
 setcon - set current security context of a process.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int getcon(security_context_t *" context );
-.br 
+
 .BI "int getprevcon(security_context_t *" context );
-.br
+
 .BI "int getpidcon(pid_t " pid ", security_context_t *" context );
-.br
+
 .BI "int getpeercon(int " fd ", security_context_t *" context);
-.br
+
 .BI "int setcon(security_context_t " context);
 
 .SH "DESCRIPTION"
@@ -59,4 +59,4 @@
 On error -1 is returned.  On success 0 is returned.
 
 .SH "SEE ALSO"
-.BR freecon "(3), " setexeccon "(3)"
+.BR selinux "(8), " freecon "(3), " setexeccon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getexeccon.3 libselinux-1.33.4/man/man3/getexeccon.3
--- nsalibselinux/man/man3/getexeccon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/getexeccon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,16 +1,16 @@
-.TH "getexeccon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "getexeccon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-getexeccon, setexeccon \- get or set the SE Linux security context used for executing a new process.
-.br
+getexeccon, setexeccon \- get or set the SELinux security context used for executing a new process.
+
 rpm_execcon \- run a helper for rpm in an appropriate security context
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int getexeccon(security_context_t *" context );
-.br 
+
 .BI "int setexeccon(security_context_t "context );
-.br 
+
 .BI "int rpm_execcon(unsigned int " verified ", const char *" filename ", char *const " argv "[] , char *const " envp "[]);
 
 .SH "DESCRIPTION"
@@ -26,16 +26,16 @@
 setexeccon to reset to the default policy behavior.  
 The exec context is automatically reset after the next execve, so a
 program doesn't need to explicitly sanitize it upon startup.  
-.br
+
 
 setexeccon can be applied prior to library
 functions that internally perform an execve, e.g. execl*, execv*, popen,
 in order to set an exec context for that operation.  
-.br
+
 
 Note: Signal handlers that perform an execve must take care to
-save, reset, and restore the exec context to avoid unexpected behaviors.
-.br
+save, reset, and restore the exec context to avoid unexpected behavior.
+
 
 .B rpm_execcon
 runs a helper for rpm in an appropriate security context.  The
@@ -55,6 +55,6 @@
 rpm_execcon only returns upon errors, as it calls execve(2).
 
 .SH "SEE ALSO"
-.BR freecon "(3), " getcon "(3)"
+.BR selinux "(8), " freecon "(3), " getcon "(3)"
 
 
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getfilecon.3 libselinux-1.33.4/man/man3/getfilecon.3
--- nsalibselinux/man/man3/getfilecon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/getfilecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,13 +1,13 @@
-.TH "getfilecon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "getfilecon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-getfilecon, fgetfilecon, lgetfilecon \- get SE Linux security context of a file
+getfilecon, fgetfilecon, lgetfilecon \- get SELinux security context of a file
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int getfilecon(const char *" path ", security_context_t *" con );
-.br 
+
 .BI "int lgetfilecon(const char *" path ", security_context_t *" con );
-.br 
+
 .BI "int fgetfilecon(int "fd ", security_context_t *" con );
 .SH "DESCRIPTION"
 .B getfilecon
@@ -22,7 +22,6 @@
 is identical to getfilecon, only the open file pointed to by filedes (as
 returned by open(2)) is interrogated in place of path.
 
-.br
 
 The returned context should be freed with freecon if non-NULL.  
 .SH "RETURN VALUE"
@@ -40,4 +39,4 @@
 here.
 
 .SH "SEE ALSO"
-.BR freecon "(3), " setfilecon "(3), " setfscreatecon "(3)"
+.BR selinux "(8), " freecon "(3), " setfilecon "(3), " setfscreatecon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getfscreatecon.3 libselinux-1.33.4/man/man3/getfscreatecon.3
--- nsalibselinux/man/man3/getfscreatecon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/getfscreatecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,12 +1,12 @@
-.TH "getfscreatecon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "getfscreatecon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-getfscreatecon, setfscreatecon \- get or set the SE Linux security context used for creating a new file system object.
+getfscreatecon, setfscreatecon \- get or set the SELinux security context used for creating a new file system object.
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int getfscreatecon(security_context_t *" con );
-.br 
+
 .BI "int setfscreatecon(security_context_t "context );
 
 .SH "DESCRIPTION"
@@ -22,17 +22,17 @@
 setfscreatecon to reset to the default policy behavior.  
 The fscreate context is automatically reset after the next execve, so a
 program doesn't need to explicitly sanitize it upon startup.  
-.br
+
 setfscreatecon can be applied prior to library
 functions that internally perform an file creation,
 in order to set an file context on the objects.
-.br
+
 
 Note: Signal handlers that perform an setfscreate must take care to
-save, reset, and restore the fscreate context to avoid unexpected behaviors.
+save, reset, and restore the fscreate context to avoid unexpected behavior.
 .SH "RETURN VALUE"
 On error -1 is returned.
 On success 0 is returned.
 
 .SH "SEE ALSO"
-.BR freecon "(3), " getcon "(3), " getexeccon "(3)"
+.BR selinux "(8), " freecon "(3), " getcon "(3), " getexeccon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getkeycreatecon.3 libselinux-1.33.4/man/man3/getkeycreatecon.3
--- nsalibselinux/man/man3/getkeycreatecon.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/getkeycreatecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,38 @@
+.TH "getkeycreatecon" "3" "9 September 2008" "dwalsh@redhat.com from russell@coker.com.au" "SELinux API documentation"
+.SH "NAME"
+getkeycreatecon, setkeycreatecon \- get or set the SELinux security context used for creating a new kernel keyrings.
+
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+.sp
+.BI "int getkeycreatecon(security_context_t *" con );
+
+.BI "int setkeycreatecon(security_context_t "context );
+
+.SH "DESCRIPTION"
+.B getkeycreatecon
+retrieves the context used for creating a new kernel keyring.
+This returned context should be freed with freecon if non-NULL.  
+getkeycreatecon sets *con to NULL if no keycreate context has been explicitly 
+set by the program (i.e. using the default policy behavior).
+
+.B setkeycreatecon
+sets the context used for creating a new kernel keyring.
+NULL can be passed to
+setkeycreatecon to reset to the default policy behavior.  
+The keycreate context is automatically reset after the next execve, so a
+program doesn't need to explicitly sanitize it upon startup.  
+
+setkeycreatecon can be applied prior to library
+functions that internally perform an file creation,
+in order to set an file context on the objects.
+
+
+Note: Signal handlers that perform an setkeycreate must take care to
+save, reset, and restore the keycreate context to avoid unexpected behavior.
+.SH "RETURN VALUE"
+On error -1 is returned.
+On success 0 is returned.
+
+.SH "SEE ALSO"
+.BR selinux "(8), " freecon "(3), " getcon "(3), " getexeccon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/get_ordered_context_list.3 libselinux-1.33.4/man/man3/get_ordered_context_list.3
--- nsalibselinux/man/man3/get_ordered_context_list.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/get_ordered_context_list.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,10 +1,10 @@
-.TH "get_ordered_context_list" "3" "1 January 2004" "russell@coker.com.au" "SE Linux"
+.TH "get_ordered_context_list" "3" "1 January 2004" "russell@coker.com.au" "SELinux"
 .SH "NAME"
-get_ordered_context_list, get_ordered_context_list_with_level, get_default_context, get_default_context_with_level, get_default_context_with_role, get_default_context_with_rolelevel, query_user_context, manual_user_enter_context, get_default_role \- determine context(s) for user sessions
+get_ordered_context_list, get_ordered_context_list_with_level, get_default_context, get_default_context_with_level, get_default_context_with_role, get_default_context_with_rolelevel, query_user_context, manual_user_enter_context, get_default_role \- determine SELinux context(s) for user sessions
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/get_context_list.h>
 .sp
 .BI "int get_ordered_context_list(const char *" user ", security_context_t "fromcon ", security_context_t **" list );
@@ -77,4 +77,4 @@
 The other functions return 0 for success or -1 for errors.
 
 .SH "SEE ALSO"
-.BR freeconary "(3), " freecon "(3), " security_compute_av "(3)", getseuserbyname"(3)"
+.BR selinux "(8), " freeconary "(3), " freecon "(3), " security_compute_av "(3)", getseuserbyname"(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/getseuserbyname.3 libselinux-1.33.4/man/man3/getseuserbyname.3
--- nsalibselinux/man/man3/getseuserbyname.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/getseuserbyname.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,4 +1,4 @@
-.TH "getseuserbyname" "3" "29 September 2005" "dwalsh@redhat.com" "SE Linux API documentation"
+.TH "getseuserbyname" "3" "29 September 2005" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
 getseuserbyname \- get SELinux username and level for a given Linux username
 .SH "SYNOPSIS"
@@ -12,7 +12,7 @@
 then be passed to other libselinux functions such as 
 get_ordered_context_list_with_level and get_default_context_with_level.
 
-.br
+
 
 The returned SELinux username and level should be freed by the caller
 using free.  
@@ -23,3 +23,6 @@
 The errors documented for the stat(2) system call are also applicable
 here.
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/is_context_customizable.3 libselinux-1.33.4/man/man3/is_context_customizable.3
--- nsalibselinux/man/man3/is_context_customizable.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/is_context_customizable.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
 .TH "is_context_customizable" "3" "10 January 2005" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
-is_context_customizable \- check whether context type is customizable by the administrator.
+is_context_customizable \- check whether SELinux context type is customizable by the administrator.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -8,7 +8,7 @@
 
 .SH "DESCRIPTION"
 .B is_context_customizable
-.br
+
 This function checks whether the type of scon is in the /etc/selinux/SELINUXTYPE/context/customizable_types file.  A customizable type is a file context type that
 administrators set on files, usually to allow certain domains to share the file content. restorecon and setfiles, by default, leave these context in place.
 
@@ -20,3 +20,6 @@
 .SH "FILE"
 /etc/selinux/SELINUXTYPE/context/customizable_types
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/is_selinux_enabled.3 libselinux-1.33.4/man/man3/is_selinux_enabled.3
--- nsalibselinux/man/man3/is_selinux_enabled.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/is_selinux_enabled.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
-.TH "is_selinux_enabled" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "is_selinux_enabled" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-is_selinux_enabled \- check whether SE Linux is enabled
+is_selinux_enabled \- check whether SELinux is enabled
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -8,4 +8,8 @@
 
 .SH "DESCRIPTION"
 .B is_selinux_enabled
-returns 1 if SE Linux is running or 0 if it is not.  May change soon.
+returns 1 if SELinux is running or 0 if it is not.  May change soon.
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/lgetfilecon.3 libselinux-1.33.4/man/man3/lgetfilecon.3
--- nsalibselinux/man/man3/lgetfilecon.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/lgetfilecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/getfilecon.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/matchmediacon.3 libselinux-1.33.4/man/man3/matchmediacon.3
--- nsalibselinux/man/man3/matchmediacon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/matchmediacon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,19 +1,19 @@
-.TH "matchmediacon" "3" "15 November 2004" "dwalsh@redhat.com" "SE Linux API documentation"
+.TH "matchmediacon" "3" "15 November 2004" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
-matchmediacon \- get the default security context for the specified mediatype from the policy.
+matchmediacon \- get the default SELinux security context for the specified mediatype from the policy.
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int matchmediacon(const char *" media ", security_context_t *" con);"
-.br 
+
 
 .SH "DESCRIPTION"
-.br
+
 .B matchmediacon 
 matches the specified media type with the media contexts configuration and sets the security context "con" to refer to the resulting context. 
 .sp
-.br
+
 .B Note: 
    Caller must free returned security context "con" using freecon.
 .SH "RETURN VALUE"
@@ -23,4 +23,4 @@
 /etc/selinux/POLICYTYPE/contexts/files/media
 
 .SH "SEE ALSO"
-.BR freecon "(3)
+.BR selinux "(8), " freecon "(3)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/matchpathcon.3 libselinux-1.33.4/man/man3/matchpathcon.3
--- nsalibselinux/man/man3/matchpathcon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/matchpathcon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,23 +1,23 @@
-.TH "matchpathcon" "3" "16 March 2005" "sds@tycho.nsa.gov" "SE Linux API documentation"
+.TH "matchpathcon" "3" "16 March 2005" "sds@tycho.nsa.gov" "SELinux API documentation"
 .SH "NAME"
-matchpathcon \- get the default security context for the specified path from the file contexts configuration.
+matchpathcon \- get the default SELinux security context for the specified path from the file contexts configuration.
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int matchpathcon_init(const char *" path ");"
-.br
+
 .BI "int matchpathcon_fini(void);"
-.br
+
 .BI "int matchpathcon(const char *" path ", mode_t " mode ", security_context_t *" con);
 .sp
-.br 
+
 .BI "void set_matchpathcon_printf(void (*" f ")(const char *" fmt ", ...));"
-.br
+
 .BI "void set_matchpathcon_invalidcon(int (*" f ")(const char *"path ", unsigned " lineno ", char * " context "));"
-.br
+
 .BI "void set_matchpathcon_flags(unsigned int " flags ");"
-.br
+
 .SH "DESCRIPTION"
 .B matchpathcon_init
 loads the file contexts configuration specified by
@@ -40,7 +40,7 @@
 suffix are also looked up and loaded if present.  These files provide
 dynamically generated entries for user home directories and for local
 customizations.
-.br 
+
 .sp
 .B matchpathcon_fini
 frees the memory allocated by a prior call to
@@ -49,7 +49,7 @@
 .B matchpathcon_init 
 calls, or to free memory when finished using 
 .B matchpathcon.
-.br
+
 .sp
 .B matchpathcon 
 matches the specified pathname and mode against the file contexts
@@ -72,14 +72,14 @@
 .I path,
 defaulting to the active file contexts configuration.
 .sp
-.br
+
 .B set_matchpathcon_printf
 sets the function used by 
 .B matchpathcon_init
 when displaying errors about the file contexts configuration.  If not set, 
 then this defaults to fprintf(stderr, fmt, ...).  This can be set to redirect
 error reporting to a different destination.
-.br
+
 .sp
 .B set_matchpathcon_invalidcon
 sets the function used by 
@@ -100,7 +100,7 @@
 and
 .I lineno
 in such error messages.
-.br
+
 .sp
 .B set_matchpathcon_flags
 sets flags controlling the operation of 
@@ -111,10 +111,10 @@
 .B MATCHPATHCON_BASEONLY
 flag is set, then only the base file contexts configuration file
 will be processed, not any dynamically generated entries or local customizations.
-.br
+
 .sp
 .SH "RETURN VALUE"
 Returns 0 on success or -1 otherwise.
 
 .SH "SEE ALSO"
-.BR freecon "(3), " setfilecon "(3), " setfscreatecon "(3)"
+.BR selinux "(8), " freecon "(3), " setfilecon "(3), " setfscreatecon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_av_perm_to_string.3 libselinux-1.33.4/man/man3/security_av_perm_to_string.3
--- nsalibselinux/man/man3/security_av_perm_to_string.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_av_perm_to_string.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_class_to_string.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_av_string.3 libselinux-1.33.4/man/man3/security_av_string.3
--- nsalibselinux/man/man3/security_av_string.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_av_string.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_class_to_string.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_check_context.3 libselinux-1.33.4/man/man3/security_check_context.3
--- nsalibselinux/man/man3/security_check_context.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_check_context.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
-.TH "security_check_context" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "security_check_context" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-security_check_context \- check the validity of a context
+security_check_context \- check the validity of a SELinux context
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -8,5 +8,9 @@
 
 .SH "DESCRIPTION"
 .B security_check_context
-returns 0 if SE Linux is running and the context is valid, otherwise it
+returns 0 if SELinux is running and the context is valid, otherwise it
 returns -1.
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_class_to_string.3 libselinux-1.33.4/man/man3/security_class_to_string.3
--- nsalibselinux/man/man3/security_class_to_string.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_class_to_string.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,80 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "security_class_to_string" "3" "30 Mar 2007" "" "SELinux API documentation"
+.SH "NAME"
+security_class_to_string, security_av_perm_to_string, string_to_security_class, string_to_av_perm, security_av_string \- convert
+between SELinux class and permission values and string names.
+
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/flask.h>
+.sp
+.BI "const char * security_class_to_string(security_class_t " tclass ");"
+.sp
+.BI "const char * security_av_perm_to_string(security_class_t " tclass ", access_vector_t " av ");"
+.sp
+.BI "int security_av_string(security_class_t " tclass ", access_vector_t " av ", char **" result ");"
+.sp
+.BI "security_class_t string_to_security_class(const char *" name ");"
+.sp
+.BI "access_vector_t string_to_av_perm(security_class_t " tclass ", const char *" name ");"
+
+.SH "DESCRIPTION"
+.B security_class_to_string
+returns a string name for class
+.IR tclass ,
+or NULL if the class is invalid.  The returned string must not be modified or freed.
+
+.B security_av_perm_to_string
+returns a string name for the access vector bit
+.I av
+of class
+.IR tclass ,
+or NULL if either argument is invalid.  The returned string must not be modified or freed.
+
+.B security_av_string
+computes a full access vector string representation using
+.I tclass
+and
+.IR av ,
+which may have multiple bits set.  The string is returned in the memory pointed to by
+.IR result ,
+and should be freed by the caller using
+.BR free (3).
+
+.B string_to_security_class
+returns the class value corresponding to the string name
+.IR name ,
+or zero if no such class exists.
+
+.B string_to_av_perm
+returns the access vector bit corresponding to the string name
+.I name
+and security class
+.IR tclass ,
+or zero if no such value exists.
+
+.SH "RETURN VALUE"
+.B security_av_string
+returns returns zero on success or \-1 on error with
+.I errno
+set appropriately.  All other functions return zero or NULL on error.
+
+.SH "ERRORS"
+.TP
+.B EINVAL
+A class or access vector argument is not recognized by the currently loaded policy.
+
+.TP
+.B ENOMEM
+An attempt to allocate memory failed.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selinux (8),
+.BR getcon (3),
+.BR getfilecon (3)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_compute_av.3 libselinux-1.33.4/man/man3/security_compute_av.3
--- nsalibselinux/man/man3/security_compute_av.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_compute_av.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,11 +1,12 @@
-.TH "security_compute_av" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "security_compute_av" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-security_compute_av, security_compute_create, security_compute_relabel, security_compute_user \- query
-the SE Linux policy database in the kernel.
+security_compute_av, security_compute_create, security_compute_relabel,
+security_compute_member, security_compute_user, security_get_initial_context \- query
+the SELinux policy database in the kernel.
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
-.br
+
 .B #include <selinux/flask.h>
 .sp
 .BI "int security_compute_av(security_context_t "scon ", security_context_t "tcon ", security_class_t "tclass ", access_vector_t "requested ", struct av_decision *" avd );
@@ -14,8 +15,13 @@
 .sp
 .BI "int security_compute_relabel(security_context_t "scon ", security_context_t "tcon ", security_class_t "tclass ", security_context_t *" newcon );
 .sp
+.BI "int security_compute_member(security_context_t "scon ", security_context_t "tcon ", security_class_t "tclass ", security_context_t *" newcon );
+.sp
 .BI "int security_compute_user(security_context_t "scon ", const char *" username ", security_context_t **" con );
 .sp
+.BI "int security_get_initial_context(const char *" name ", security_context_t
+"con );
+.sp
 .BI "int checkPasswdAccess(access_vector_t " requested );
 
 .SH "DESCRIPTION"
@@ -39,11 +45,19 @@
 in the pam_selinux.so source and the newrole source to determine the correct
 label for the tty at login time, but can be used for other things.
 
+.B security_compute_member
+is used to compute the context to use when labeling a polyinstantiated object
+instance.
+
 .B security_compute_user
 is used to determine the set of user contexts that can be reached from a
 source context. Is mainly used by
 .B get_ordered_context_list.
 
+.B security_get_initial_context
+is used to get the context of a kernel initial security identifier specified by 
+.I name
+
 .B checkPasswdAccess
 This functions is a helper functions that allows you to check for a permission in the passwd class. checkPasswdAccess uses getprevcon() for the source and target security contexts.
 
@@ -51,4 +65,4 @@
 0 for success and on error -1 is returned.
 
 .SH "SEE ALSO"
-.BR getcon "(3), " getfilecon "(3), " get_ordered_context_list "(3)"
+.BR selinux "(8), " getcon "(3), " getfilecon "(3), " get_ordered_context_list "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_compute_member.3 libselinux-1.33.4/man/man3/security_compute_member.3
--- nsalibselinux/man/man3/security_compute_member.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_compute_member.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_compute_av.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_getenforce.3 libselinux-1.33.4/man/man3/security_getenforce.3
--- nsalibselinux/man/man3/security_getenforce.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_getenforce.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,19 +1,23 @@
-.TH "security_getenforce" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "security_getenforce" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-security_getenforce, security_setenforce \- get or set the enforcing state of SE Linux
+security_getenforce, security_setenforce \- get or set the enforcing state of SELinux
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .B int security_getenforce();
-.br
+
 .BI "int security_setenforce(int "value );
 
 .SH "DESCRIPTION"
 .B security_getenforce
-returns 0 if SE Linux is running in permissive mode, 1 if it is running in
+returns 0 if SELinux is running in permissive mode, 1 if it is running in
 enforcing mode, and -1 on error.
 
 .B security_setenforce
-sets SE Linux to enforcing mode if the value 1 is passed in, and sets it to
+sets SELinux to enforcing mode if the value 1 is passed in, and sets it to
 permissive mode if 0 is passed in.  On success 0 is returned, on error -1 is
 returned.
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_get_initial_context.3 libselinux-1.33.4/man/man3/security_get_initial_context.3
--- nsalibselinux/man/man3/security_get_initial_context.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_get_initial_context.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_compute_av.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_load_booleans.3 libselinux-1.33.4/man/man3/security_load_booleans.3
--- nsalibselinux/man/man3/security_load_booleans.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_load_booleans.3	2010-07-19 19:36:18.000000000 +0200
@@ -7,15 +7,15 @@
 .B #include <selinux/selinux.h>
 .sp
 extern int security_load_booleans(char *path);
-.br
+
 extern int security_get_boolean_names(char ***names, int *len);
-.br
+
 extern int security_get_boolean_pending(const char *name);
-.br
+
 extern int security_get_boolean_active(const char *name);
-.br
+
 extern int security_set_boolean(const char *name, int value);
-.br
+
 extern int security_commit_booleans(void);
 
 
@@ -29,31 +29,31 @@
 The SELinux API allows for a transaction based update.  So you can set several boolean values and the commit them all at once.
 
 security_load_booleans
-.br
+
 Load policy boolean settings. Path may be NULL, in which case the booleans are loaded from the active policy boolean configuration file.
 
 security_get_boolean_names
-.br
+
 Returns a list of boolean names, currently supported by the loaded policy.
 
 security_set_boolean 
-.br
+
 Sets the pending value for boolean 
 
 security_get_boolean_pending
-.br
+
 Return pending value for boolean
 
 security_get_boolean_active
-.br
+
 Return active value for boolean
 
 security_commit_booleans
-.br
+
 Commit all pending values for the booleans.
 
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 
 .SH "SEE ALSO"
-getsebool(8), booleans(8), togglesebool(8)
+selinux(8), getsebool(8), booleans(8), togglesebool(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_load_policy.3 libselinux-1.33.4/man/man3/security_load_policy.3
--- nsalibselinux/man/man3/security_load_policy.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_load_policy.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
-.TH "security_load_policy" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "security_load_policy" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-security_load_policy \- load a new policy
+security_load_policy \- load a new SELinux policy
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -9,3 +9,7 @@
 .SH "DESCRIPTION"
 .B security_load_policy
 loads a new policy, returns 0 for success and -1 for error.
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/security_policyvers.3 libselinux-1.33.4/man/man3/security_policyvers.3
--- nsalibselinux/man/man3/security_policyvers.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/security_policyvers.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
-.TH "security_policyvers" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "security_policyvers" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-security_policyvers \- get the version of the SE Linux policy
+security_policyvers \- get the version of the SELinux policy
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -10,3 +10,7 @@
 .B security_policyvers
 returns the version of the policy (a positive integer) on success, or -1 on
 error.
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selabel_close.3 libselinux-1.33.4/man/man3/selabel_close.3
--- nsalibselinux/man/man3/selabel_close.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selabel_close.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/selabel_open.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selabel_lookup.3 libselinux-1.33.4/man/man3/selabel_lookup.3
--- nsalibselinux/man/man3/selabel_lookup.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selabel_lookup.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,78 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "selabel_lookup" "3" "18 Jun 2007" "" "SELinux API documentation"
+.SH "NAME"
+selabel_lookup \- obtain SELinux security context from a string label.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/label.h>
+.sp
+.BI "int selabel_lookup(struct selabel_handle *" hnd ,
+.in +\w'int selabel_lookup('u
+.BI "security_context_t *" context ,
+
+.BI "const char *" key ", int " type ");"
+.in
+.sp
+.BI "int selabel_lookup_raw(struct selabel_handle *" hnd ,
+.in +\w'int selabel_lookup_raw('u
+.BI "security_context_t *" context ,
+
+.BI "const char *" key ", int " type ");"
+
+.SH "DESCRIPTION"
+.B selabel_lookup
+performs a lookup operation on the handle 
+.IR hnd ,
+returning the result in the memory pointed to by 
+.IR context ,
+which must be freed by the caller using
+.BR freecon (3).
+The 
+.I key
+and
+.I type
+parameters are the inputs to the lookup operation and are interpreted according to the specific backend that 
+.I handle
+is open on.
+
+.B selabel_lookup_raw
+behaves identically to 
+.B selabel_lookup
+but does not perform context translation.
+
+.SH "RETURN VALUE"
+On success, zero is returned.  On error, \-1 is returned and
+.I errno
+is set appropriately.
+
+.SH "ERRORS"
+.TP
+.B ENOENT
+No context corresponding to the input 
+.I key
+and
+.I type
+was found.
+.TP
+.B EINVAL
+The
+.I key
+and/or
+.I type
+inputs are invalid, or the context being returned failed validation.
+.TP
+.B ENOMEM
+An attempt to allocate memory failed.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selabel_open (3),
+.BR selabel_stats (3),
+.BR selinux_set_callback (3),
+.BR selinux (8)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selabel_open.3 libselinux-1.33.4/man/man3/selabel_open.3
--- nsalibselinux/man/man3/selabel_open.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selabel_open.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,98 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "selabel_open" "3" "18 Jun 2007" "" "SELinux API documentation"
+.SH "NAME"
+selabel_open, selabel_close \- userspace SELinux labeling interface.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/label.h>
+.sp
+.BI "struct selabel_handle *selabel_open(int " backend , 
+.in +\w'struct selabel_handle *selabel_open('u
+.BI "struct selinux_opt *" options ,
+
+.BI "unsigned " nopt ");"
+.in
+.sp
+.BI "void selabel_close(struct selabel_handle *" hnd ");"
+
+.SH "DESCRIPTION"
+.B selabel_open
+is used to initialize a labeling handle to be used for lookup operations.  The 
+.I backend
+argument specifies which backend is to be opened; the list of current backends appears in 
+.B BACKENDS
+below.
+
+The 
+.I options
+argument should be NULL or a pointer to an array of 
+.B selinux_opt
+structures of length
+.IR nopt :
+
+.RS
+.ta 4n 16n 24n
+.nf
+struct selinux_opt {
+	int	type;
+	const char	*value;
+};
+.fi
+.ta
+.RE
+
+The available option types are described in 
+.B GLOBAL OPTIONS
+below as well as in the documentation for each individual backend.  The return value on success is a non-NULL value for use in subsequent label operations.
+
+.B selabel_close
+terminates use of a handle, freeing any internal resources associated with it.  After this call has been made, the handle must not be used again.
+
+.SH "GLOBAL OPTIONS"
+Global options which may be passed to
+.B selabel_open
+include the following:
+
+.TP
+.B SELABEL_OPT_UNUSED
+The option with a type code of zero is a no-op.  Thus an array of options may be initizalized to zero and any untouched elements will not cause an error.
+.TP
+.B SELABEL_OPT_VALIDATE
+A non-null value for this option enables context validation.  By default,
+.BR security_check_context (3)
+is used; a custom validation function can be provided via
+.BR selinux_set_callback (3).
+Note that an invalid context may not be treated as an error unless it is actually encountered during a lookup operation.
+
+.SH "BACKENDS"
+
+.TP
+.B SELABEL_CTX_FILE
+File contexts backend, described in 
+.BR selabel_file (3).
+.TP
+.B SELABEL_CTX_MEDIA
+Media contexts backend, described in 
+.BR selabel_media (3).
+.TP
+.B SELABEL_CTX_X
+X Windows contexts backend, described in 
+.BR selabel_x (3).
+
+.SH "RETURN VALUE"
+A non-NULL handle value is returned on success.  On error, NULL is returned and
+.I errno
+is set appropriately.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selabel_lookup (3),
+.BR selabel_stats (3),
+.BR selinux_set_callback (3),
+.BR selinux (8)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selabel_stats.3 libselinux-1.33.4/man/man3/selabel_stats.3
--- nsalibselinux/man/man3/selabel_stats.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selabel_stats.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,35 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "selabel_stats" "3" "18 Jun 2007" "" "SELinux API documentation"
+.SH "NAME"
+selabel_stats \- obtain SELinux labeling statistics.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+
+.B #include <selinux/label.h>
+.sp
+.BI "void selabel_lookup(struct selabel_handle *" hnd ");"
+
+.SH "DESCRIPTION"
+.B selabel_stats
+causes zero or more messages to be printed containing backend-specific information about number of queries performed, number of unused entries, or other operational information.
+
+The messages are printed to standard error by default; a custom logging function can be provided via 
+.BR selinux_set_callback (3).
+
+.SH "RETURN VALUE"
+None.
+
+.SH "ERRORS"
+None.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selabel_open (3),
+.BR selabel_lookup (3),
+.BR selinux_set_callback (3),
+.BR selinux (8)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_binary_policy_path.3 libselinux-1.33.4/man/man3/selinux_binary_policy_path.3
--- nsalibselinux/man/man3/selinux_binary_policy_path.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_binary_policy_path.3	2010-07-19 19:36:18.000000000 +0200
@@ -4,33 +4,33 @@
 selinux_failsafe_context_path, selinux_removable_context_path,
 selinux_default_context_path, selinux_user_contexts_path,
 selinux_file_context_path, selinux_media_context_path,
-selinux_contexts_path, selinux_booleans_path \- These functions return the paths to the active policy configuration
+selinux_contexts_path, selinux_booleans_path \- These functions return the paths to the active SELinux policy configuration
 directories and files.
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
-.br
+
 extern const char *selinux_policy_root(void);
-.br
+
 extern const char *selinux_binary_policy_path(void);
-.br
+
 extern const char *selinux_failsafe_context_path(void);
-.br
+
 extern const char *selinux_removable_context_path(void);
-.br
+
 extern const char *selinux_default_context_path(void);
-.br
+
 extern const char *selinux_user_contexts_path(void);
-.br
+
 extern const char *selinux_file_context_path(void);
-.br
+
 extern const char *selinux_media_context_path(void);
-.br
+
 extern const char *selinux_securetty_types_path(void);
-.br
+
 extern const char *selinux_contexts_path(void);
-.br
+
 extern const char *selinux_booleans_path(void);
 
 
@@ -65,3 +65,6 @@
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_check_securetty_context.3 libselinux-1.33.4/man/man3/selinux_check_securetty_context.3
--- nsalibselinux/man/man3/selinux_check_securetty_context.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_check_securetty_context.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
-.TH "selinux_check_securetty_context" "3" "1 January 2007" "dwalsh@redhat.com" "SE Linux API documentation"
+.TH "selinux_check_securetty_context" "3" "1 January 2007" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
-selinux_check_securetty_context \- check whether a tty security context is defined as a securetty context
+selinux_check_securetty_context \- check whether a SELinux tty security context is defined as a securetty context
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
@@ -10,3 +10,7 @@
 .B selinux_check_securetty_context
 returns 0 if tty_context is a securetty context
 returns < 0 otherwise. 
+
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_getenforcemode.3 libselinux-1.33.4/man/man3/selinux_getenforcemode.3
--- nsalibselinux/man/man3/selinux_getenforcemode.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_getenforcemode.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,17 +1,17 @@
-.TH "selinux_getenforcemode" "3" "25 May 2004" "dwalsh@redhat.com" "SE Linux API documentation"
+.TH "selinux_getenforcemode" "3" "25 May 2004" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
-selinux_getenforcemode \- get the enforcing state of SE Linux
+selinux_getenforcemode \- get the enforcing state of SELinux
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .B int selinux_getenforcemode(int *enforce);
-.br
+
 
 .SH "DESCRIPTION"
 .B selinux_getenforcemode
 Reads the contents of the /etc/selinux/config file to determine how the 
 system was setup to run SELinux.
-.br
+
 Sets the value of enforce to 1 if SELinux should be run in enforcing mode.
 Sets the value of enforce to 0 if SELinux should be run in permissive mode.
 Sets the value of enforce to -1 if SELinux should be disabled.
@@ -19,4 +19,7 @@
 On success, zero is returned.
 On failure, -1 is returned.
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
 
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_policy_root.3 libselinux-1.33.4/man/man3/selinux_policy_root.3
--- nsalibselinux/man/man3/selinux_policy_root.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_policy_root.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,11 +1,11 @@
-.TH "selinux_policy_root" "3" "25 May 2004" "dwalsh@redhat.com" "SE Linux API documentation"
+.TH "selinux_policy_root" "3" "25 May 2004" "dwalsh@redhat.com" "SELinux API documentation"
 .SH "NAME"
 selinux_policy_root \- return the path of the SELinux policy files for this machine.
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .B char *selinux_policy_root();
-.br
+
 
 .SH "DESCRIPTION"
 .B selinux_policy_root
@@ -14,4 +14,7 @@
 On success, returns a directory path containing the SELinux policy files.
 On failure, NULL is returned.
 
+.SH "SEE ALSO"
+.BR selinux "(8)"
+
 
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_set_callback.3 libselinux-1.33.4/man/man3/selinux_set_callback.3
--- nsalibselinux/man/man3/selinux_set_callback.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_set_callback.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,95 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2007
+.TH "selinux_set_callback" "3" "20 Jun 2007" "" "SELinux API documentation"
+.SH "NAME"
+selinux_set_callback \- userspace SELinux callback facilities.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+.sp
+.BI "void selinux_set_callback(int " type ", union selinux_callback " callback ");"
+
+.SH "DESCRIPTION"
+.B selinux_set_callback
+sets the callback indicated by
+.I type
+to the value of
+.IR callback ,
+which should be passed as a function pointer cast to type
+.B union
+.BR selinux_callback .
+
+All callback functions should return a negative value with
+.I errno
+set appropriately on error.
+
+The available values for 
+.I type
+are:
+.TP
+.B SELINUX_CB_LOG
+.BI "int (*" func_log ") (int " type ", const char *" fmt ", ...);"
+
+This callback is used for logging and should process the 
+.BR printf (3)
+style 
+.I fmt
+string and arguments as appropriate.  The
+.I type
+argument indicates the type of message and will be set to one of the following:
+
+.B SELINUX_ERROR
+
+.B SELINUX_WARNING
+
+.B SELINUX_INFO
+
+.B SELINUX_AVC
+
+.TP
+.B SELINUX_CB_AUDIT
+.BI "int (*" func_audit ") (void *" auditdata ", security_class_t " cls ,
+.in +\w'int (*func_audit) ('u
+.BI "char *" msgbuf ", size_t " msgbufsize ");"
+.in
+
+This callback is used for supplemental auditing in AVC messages.  The
+.I auditdata
+and
+.I cls
+arguments are the values passed to
+.BR avc_has_perm (3).
+A human-readable interpretation should be printed to
+.I msgbuf
+using no more than
+.I msgbufsize
+characters.
+
+.TP
+.B SELINUX_CB_VALIDATE
+.BI "int (*" func_validate ") (security_context_t *" ctx ");"
+
+This callback is used for context validation.  The callback may optionally modify the input context by setting the target of the 
+.I ctx
+pointer to a new context.  In this case, the old value should be freed with
+.BR freecon (3).
+The value of
+.I errno
+should be set to
+.B EINVAL
+to indicate an invalid context.
+
+.SH "RETURN VALUE"
+None.
+
+.SH "ERRORS"
+None.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR selabel_open (3),
+.BR avc_init (3),
+.BR selinux (8)
+
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/selinux_set_mapping.3 libselinux-1.33.4/man/man3/selinux_set_mapping.3
--- nsalibselinux/man/man3/selinux_set_mapping.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/selinux_set_mapping.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,87 @@
+.\" Hey Emacs! This file is -*- nroff -*- source.
+.\"
+.\" Author: Eamon Walsh (ewalsh@tycho.nsa.gov) 2008
+.TH "selinux_set_mapping" "3" "12 Jun 2008" "" "SELinux API documentation"
+.SH "NAME"
+selinux_set_mapping \- establish dynamic object class and permission mapping.
+.SH "SYNOPSIS"
+.B #include <selinux/selinux.h>
+.sp
+.nf
+struct security_class_mapping {
+	const char *name;
+	const char *perms[];
+};
+.fi
+.sp
+.BI "int selinux_set_mapping(struct security_class_mapping *" map ");"
+
+.SH "DESCRIPTION"
+.B selinux_set_mapping
+establishes a mapping from a user-provided ordering of object classes and permissions to the numbers actually used by the loaded system policy.  Use of this function is highly preferred over the generated constants in the libselinux header files, as this method allows the policy's class and permission values to change over time.
+
+After the mapping is established, all libselinux functions that operate on class and permission values take the user-provided numbers, which are determined as follows:
+
+The
+.I map
+argument consists of an array of 
+.B security_class_mapping
+structures, which must be terminated by a structure having a NULL name field.  Except for this last structure, the
+.I name 
+field should refer to the string name of an object class, and the corresponding
+.I perms
+field should refer to an array of permission bit names terminated by a NULL string.
+
+The object classes named in the mapping and the bit indexes of each set of permission bits named in the mapping are numbered in order starting from 1.  These numbers are the values that should be passed to subsequent libselinux calls.
+
+.SH "RETURN VALUE"
+Zero is returned on success.  On error, -1 is returned and
+.I errno
+is set appropriately.
+
+.SH "ERRORS"
+.TP
+.B EINVAL
+One of the class or permission names requested in the mapping is not present in the loaded policy.
+.TP
+.B ENOMEM
+An attempt to allocate memory failed.
+
+.SH "EXAMPLE"
+.RS
+.ta 4n 10n
+.nf
+struct security_class_mapping map[] = {
+	{ "file", { "create", "unlink", "read", "write", NULL } },
+	{ "socket", { "bind", NULL } },
+	{ "process", { "signal", NULL } },
+	{ NULL }
+};
+
+if (selinux_set_mapping(map) < 0)
+	exit(1);
+.fi
+.ta
+.RE
+
+In this example, after the call has succeeded, classes
+.BR file ,
+.BR socket ,
+and
+.B process
+will be identified by 1, 2 and 3, respectively.  Permissions
+.IR create ,
+.IR unlink ,
+.IR read ,
+and
+.I write
+(for the 
+.B file
+class) will be identified by 1, 2, 4, and 8 respectively.  Classes and permissions not listed in the mapping cannot be used.
+
+.SH "AUTHOR"
+Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+.SH "SEE ALSO"
+.BR avc_open (8),
+.BR selinux (8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/setfilecon.3 libselinux-1.33.4/man/man3/setfilecon.3
--- nsalibselinux/man/man3/setfilecon.3	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man3/setfilecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -1,14 +1,14 @@
-.TH "setfilecon" "3" "1 January 2004" "russell@coker.com.au" "SE Linux API documentation"
+.TH "setfilecon" "3" "1 January 2004" "russell@coker.com.au" "SELinux API documentation"
 .SH "NAME"
-setfilecon, fsetfilecon, lsetfilecon \- set SE Linux security context of a file
+setfilecon, fsetfilecon, lsetfilecon \- set SELinux security context of a file
 
 .SH "SYNOPSIS"
 .B #include <selinux/selinux.h>
 .sp
 .BI "int setfilecon(const char *" path ", security_context_t "con );
-.br 
+
 .BI "int lsetfilecon(const char *" path ", security_context_t "con );
-.br 
+
 .BI "int fsetfilecon(int "fd ", security_context_t "con );
 
 .SH "DESCRIPTION"
@@ -38,4 +38,4 @@
 here.
 
 .SH "SEE ALSO"
-.BR freecon "(3), " getfilecon "(3), " setfscreatecon "(3)"
+.BR selinux "(3), " freecon "(3), " getfilecon "(3), " setfscreatecon "(3)"
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/setkeycreatecon.3 libselinux-1.33.4/man/man3/setkeycreatecon.3
--- nsalibselinux/man/man3/setkeycreatecon.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/setkeycreatecon.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/getkeycreatecon.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/string_to_av_perm.3 libselinux-1.33.4/man/man3/string_to_av_perm.3
--- nsalibselinux/man/man3/string_to_av_perm.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/string_to_av_perm.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_class_to_string.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man3/string_to_security_class.3 libselinux-1.33.4/man/man3/string_to_security_class.3
--- nsalibselinux/man/man3/string_to_security_class.3	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/man/man3/string_to_security_class.3	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1 @@
+.so man3/security_class_to_string.3
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/avcstat.8 libselinux-1.33.4/man/man8/avcstat.8
--- nsalibselinux/man/man8/avcstat.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/avcstat.8	2010-07-19 19:36:18.000000000 +0200
@@ -22,6 +22,9 @@
 .B \-f
 Specifies the location of the AVC statistics file, defaulting to '/selinux/avc/cache_stats'.
 
+.SH "SEE ALSO"
+selinux(8)
+
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 The program was written by James Morris <jmorris@redhat.com>.
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/booleans.8 libselinux-1.33.4/man/man8/booleans.8
--- nsalibselinux/man/man8/booleans.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/booleans.8	2010-07-19 19:36:18.000000000 +0200
@@ -21,7 +21,7 @@
 .B setsebool(8)
 utility, using -P to make the setting persistent across reboots.
 The 
-.B system-config-securitylevel
+.B system-config-selinux
 tool provides a graphical interface for altering
 the settings.  The
 .B load_policy(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/getenforce.8 libselinux-1.33.4/man/man8/getenforce.8
--- nsalibselinux/man/man8/getenforce.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/getenforce.8	2010-07-19 19:36:18.000000000 +0200
@@ -12,4 +12,4 @@
 Dan Walsh, <dwalsh@redhat.com>
 
 .SH "SEE ALSO"
-setenforce(8), selinuxenabled(8)
+selinux(8), setenforce(8), selinuxenabled(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/getsebool.8 libselinux-1.33.4/man/man8/getsebool.8
--- nsalibselinux/man/man8/getsebool.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/getsebool.8	2010-07-19 19:36:18.000000000 +0200
@@ -26,9 +26,10 @@
 .B \-a
 Show all SELinux booleans.
 
+.SH "SEE ALSO"
+selinux(8), setsebool(8), booleans(8)
+
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 The program was written by Tresys Technology.
 
-.SH "SEE ALSO"
-setsebool(8), booleans(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/matchpathcon.8 libselinux-1.33.4/man/man8/matchpathcon.8
--- nsalibselinux/man/man8/matchpathcon.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/matchpathcon.8	2010-07-19 19:36:18.000000000 +0200
@@ -1,25 +1,31 @@
-.TH "matchpathcon" "8" "21 April 2005" "dwalsh@redhat.com" "SE Linux Command Line documentation"
+.TH "matchpathcon" "8" "21 April 2005" "dwalsh@redhat.com" "SELinux Command Line documentation"
 .SH "NAME"
-matchpathcon \- get the default security context for the specified path from the file contexts configuration.
+matchpathcon \- get the default SELinux security context for the specified path from the file contexts configuration.
 
 .SH "SYNOPSIS"
 .B matchpathcon [-V] [-N] [-n] [-f file_contexts_file ] [-p prefix ] filepath...
 .SH "DESCRIPTION"
 .B matchpathcon
-Prints the file path and the default security context associated with it.
+queries the system policy and outputs the default security context associated with the filepath.
+
+Note: Identical paths can have different security contexts, depending on the file type. (regular file, directory, link file, char file ...)
+
+.B matchpathcon 
+will also take the file type into consideration in determining the default security context if the file exists.  If the file does not exist, no file type matching will occur.
+
 .SH OPTIONS
 .B \-n
 Do not display path.
-.br
+
 .B \-N
 Do not use translations.
-.br
+
 .B \-f file_context_file
 Use alternate file_context file
-.br
+
 .B \-p prefix
 Use prefix to speed translations
-.br
+
 .B \-V
 Verify file context on disk matches defaults
 
@@ -27,4 +33,5 @@
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 
 .SH "SEE ALSO"
-.BR mathpathcon "(3), " 
+.BR selinux "(8), "
+.BR matchpathcon "(3), " 
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/selinux.8 libselinux-1.33.4/man/man8/selinux.8
--- nsalibselinux/man/man8/selinux.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/selinux.8	2010-07-19 19:36:18.000000000 +0200
@@ -59,18 +59,17 @@
 
 A given SELinux policy can be customized further based on a set of
 compile-time tunable options and a set of runtime policy booleans.
-.B system-config-securitylevel
+.B system-config-selinux
 allows customization of these booleans and tunables.
 
-.br
 Many domains that are protected by SELinux also include selinux man pages explainging how to customize their policy.  
 
 .SH FILE LABELING
 
 All files, directories, devices ... have a security context/label associated with them.  These context are stored in the extended attributes of the file system.
 Problems with SELinux often arise from the file system being mislabeled. This can be caused by booting the machine with a non selinux kernel.  If you see an error message containing file_t, that is usually a good indicator that you have a serious problem with file system labeling.  
-.br 
-The best way to relabel the file system is to create the flag file /.autorelabel and reboot.  system-config-securitylevel, also has this capability.  The restorcon/fixfiles commands are also available for relabeling files. 
+
+The best way to relabel the file system is to create the flag file /.autorelabel and reboot.  system-config-selinux, also has this capability.  The restorcon/fixfiles commands are also available for relabeling files. 
   
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/selinuxenabled.8 libselinux-1.33.4/man/man8/selinuxenabled.8
--- nsalibselinux/man/man8/selinuxenabled.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/selinuxenabled.8	2010-07-19 19:36:18.000000000 +0200
@@ -13,4 +13,4 @@
 Dan Walsh, <dwalsh@redhat.com>
 
 .SH "SEE ALSO"
-setenforce(8), getenforce(8)
+selinux(8), setenforce(8), getenforce(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/setenforce.8 libselinux-1.33.4/man/man8/setenforce.8
--- nsalibselinux/man/man8/setenforce.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/setenforce.8	2010-07-19 19:36:18.000000000 +0200
@@ -17,7 +17,7 @@
 Dan Walsh, <dwalsh@redhat.com>
 
 .SH "SEE ALSO"
-getenforce(8), selinuxenabled(8)
+selinux(8), getenforce(8), selinuxenabled(8)
 
 .SH FILES
 /etc/grub.conf, /etc/selinux/config
diff --exclude-from=exclude -N -u -r nsalibselinux/man/man8/togglesebool.8 libselinux-1.33.4/man/man8/togglesebool.8
--- nsalibselinux/man/man8/togglesebool.8	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/man/man8/togglesebool.8	2010-07-19 19:36:18.000000000 +0200
@@ -1,6 +1,6 @@
 .TH "togglesebool" "1" "26 Oct 2004" "sgrubb@redhat.com" "SELinux Command Line documentation"
 .SH "NAME"
-togglesebool \- flip the current value of a boolean
+togglesebool \- flip the current value of a SELinux boolean
 .SH "SYNOPSIS"
 .B togglesebool boolean...
 
@@ -14,4 +14,4 @@
 This man page was written by Steve Grubb <sgrubb@redhat.com>
 
 .SH "SEE ALSO"
-booleans(8), getsebool(8), setsebool(8)
+selinux(8), booleans(8), getsebool(8), setsebool(8)
diff --exclude-from=exclude -N -u -r nsalibselinux/src/av_perm_to_string.h libselinux-1.33.4/src/av_perm_to_string.h
--- nsalibselinux/src/av_perm_to_string.h	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/src/av_perm_to_string.h	2010-07-19 19:36:18.000000000 +0200
@@ -1,269 +1,276 @@
 /* This file is automatically generated.  Do not edit. */
 S_(SECCLASS_FILESYSTEM, FILESYSTEM__MOUNT, "mount")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__REMOUNT, "remount")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__UNMOUNT, "unmount")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__GETATTR, "getattr")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__RELABELFROM, "relabelfrom")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__RELABELTO, "relabelto")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__TRANSITION, "transition")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__ASSOCIATE, "associate")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAMOD, "quotamod")
-    S_(SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAGET, "quotaget")
-    S_(SECCLASS_DIR, DIR__ADD_NAME, "add_name")
-    S_(SECCLASS_DIR, DIR__REMOVE_NAME, "remove_name")
-    S_(SECCLASS_DIR, DIR__REPARENT, "reparent")
-    S_(SECCLASS_DIR, DIR__SEARCH, "search")
-    S_(SECCLASS_DIR, DIR__RMDIR, "rmdir")
-    S_(SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, "execute_no_trans")
-    S_(SECCLASS_FILE, FILE__ENTRYPOINT, "entrypoint")
-    S_(SECCLASS_FILE, FILE__EXECMOD, "execmod")
-    S_(SECCLASS_CHR_FILE, CHR_FILE__EXECUTE_NO_TRANS, "execute_no_trans")
-    S_(SECCLASS_CHR_FILE, CHR_FILE__ENTRYPOINT, "entrypoint")
-    S_(SECCLASS_CHR_FILE, CHR_FILE__EXECMOD, "execmod")
-    S_(SECCLASS_FD, FD__USE, "use")
-    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__CONNECTTO, "connectto")
-    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NEWCONN, "newconn")
-    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__ACCEPTFROM, "acceptfrom")
-    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NODE_BIND, "node_bind")
-    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NAME_CONNECT, "name_connect")
-    S_(SECCLASS_UDP_SOCKET, UDP_SOCKET__NODE_BIND, "node_bind")
-    S_(SECCLASS_RAWIP_SOCKET, RAWIP_SOCKET__NODE_BIND, "node_bind")
-    S_(SECCLASS_NODE, NODE__TCP_RECV, "tcp_recv")
-    S_(SECCLASS_NODE, NODE__TCP_SEND, "tcp_send")
-    S_(SECCLASS_NODE, NODE__UDP_RECV, "udp_recv")
-    S_(SECCLASS_NODE, NODE__UDP_SEND, "udp_send")
-    S_(SECCLASS_NODE, NODE__RAWIP_RECV, "rawip_recv")
-    S_(SECCLASS_NODE, NODE__RAWIP_SEND, "rawip_send")
-    S_(SECCLASS_NODE, NODE__ENFORCE_DEST, "enforce_dest")
-    S_(SECCLASS_NETIF, NETIF__TCP_RECV, "tcp_recv")
-    S_(SECCLASS_NETIF, NETIF__TCP_SEND, "tcp_send")
-    S_(SECCLASS_NETIF, NETIF__UDP_RECV, "udp_recv")
-    S_(SECCLASS_NETIF, NETIF__UDP_SEND, "udp_send")
-    S_(SECCLASS_NETIF, NETIF__RAWIP_RECV, "rawip_recv")
-    S_(SECCLASS_NETIF, NETIF__RAWIP_SEND, "rawip_send")
-    S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__CONNECTTO, "connectto")
-    S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__NEWCONN, "newconn")
-    S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__ACCEPTFROM, "acceptfrom")
-    S_(SECCLASS_PROCESS, PROCESS__FORK, "fork")
-    S_(SECCLASS_PROCESS, PROCESS__TRANSITION, "transition")
-    S_(SECCLASS_PROCESS, PROCESS__SIGCHLD, "sigchld")
-    S_(SECCLASS_PROCESS, PROCESS__SIGKILL, "sigkill")
-    S_(SECCLASS_PROCESS, PROCESS__SIGSTOP, "sigstop")
-    S_(SECCLASS_PROCESS, PROCESS__SIGNULL, "signull")
-    S_(SECCLASS_PROCESS, PROCESS__SIGNAL, "signal")
-    S_(SECCLASS_PROCESS, PROCESS__PTRACE, "ptrace")
-    S_(SECCLASS_PROCESS, PROCESS__GETSCHED, "getsched")
-    S_(SECCLASS_PROCESS, PROCESS__SETSCHED, "setsched")
-    S_(SECCLASS_PROCESS, PROCESS__GETSESSION, "getsession")
-    S_(SECCLASS_PROCESS, PROCESS__GETPGID, "getpgid")
-    S_(SECCLASS_PROCESS, PROCESS__SETPGID, "setpgid")
-    S_(SECCLASS_PROCESS, PROCESS__GETCAP, "getcap")
-    S_(SECCLASS_PROCESS, PROCESS__SETCAP, "setcap")
-    S_(SECCLASS_PROCESS, PROCESS__SHARE, "share")
-    S_(SECCLASS_PROCESS, PROCESS__GETATTR, "getattr")
-    S_(SECCLASS_PROCESS, PROCESS__SETEXEC, "setexec")
-    S_(SECCLASS_PROCESS, PROCESS__SETFSCREATE, "setfscreate")
-    S_(SECCLASS_PROCESS, PROCESS__NOATSECURE, "noatsecure")
-    S_(SECCLASS_PROCESS, PROCESS__SIGINH, "siginh")
-    S_(SECCLASS_PROCESS, PROCESS__SETRLIMIT, "setrlimit")
-    S_(SECCLASS_PROCESS, PROCESS__RLIMITINH, "rlimitinh")
-    S_(SECCLASS_PROCESS, PROCESS__DYNTRANSITION, "dyntransition")
-    S_(SECCLASS_PROCESS, PROCESS__SETCURRENT, "setcurrent")
-    S_(SECCLASS_PROCESS, PROCESS__EXECMEM, "execmem")
-    S_(SECCLASS_PROCESS, PROCESS__EXECSTACK, "execstack")
-    S_(SECCLASS_PROCESS, PROCESS__EXECHEAP, "execheap")
-    S_(SECCLASS_PROCESS, PROCESS__SETKEYCREATE, "setkeycreate")
-    S_(SECCLASS_PROCESS, PROCESS__SETSOCKCREATE, "setsockcreate")
-    S_(SECCLASS_MSGQ, MSGQ__ENQUEUE, "enqueue")
-    S_(SECCLASS_MSG, MSG__SEND, "send")
-    S_(SECCLASS_MSG, MSG__RECEIVE, "receive")
-    S_(SECCLASS_SHM, SHM__LOCK, "lock")
-    S_(SECCLASS_SECURITY, SECURITY__COMPUTE_AV, "compute_av")
-    S_(SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE, "compute_create")
-    S_(SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER, "compute_member")
-    S_(SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, "check_context")
-    S_(SECCLASS_SECURITY, SECURITY__LOAD_POLICY, "load_policy")
-    S_(SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL, "compute_relabel")
-    S_(SECCLASS_SECURITY, SECURITY__COMPUTE_USER, "compute_user")
-    S_(SECCLASS_SECURITY, SECURITY__SETENFORCE, "setenforce")
-    S_(SECCLASS_SECURITY, SECURITY__SETBOOL, "setbool")
-    S_(SECCLASS_SECURITY, SECURITY__SETSECPARAM, "setsecparam")
-    S_(SECCLASS_SECURITY, SECURITY__SETCHECKREQPROT, "setcheckreqprot")
-    S_(SECCLASS_SYSTEM, SYSTEM__IPC_INFO, "ipc_info")
-    S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_READ, "syslog_read")
-    S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_MOD, "syslog_mod")
-    S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_CONSOLE, "syslog_console")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__CHOWN, "chown")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__DAC_OVERRIDE, "dac_override")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__DAC_READ_SEARCH, "dac_read_search")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__FOWNER, "fowner")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__FSETID, "fsetid")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__KILL, "kill")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SETGID, "setgid")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SETUID, "setuid")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SETPCAP, "setpcap")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__LINUX_IMMUTABLE, "linux_immutable")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__NET_BIND_SERVICE, "net_bind_service")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__NET_BROADCAST, "net_broadcast")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__NET_ADMIN, "net_admin")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__NET_RAW, "net_raw")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__IPC_LOCK, "ipc_lock")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__IPC_OWNER, "ipc_owner")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_MODULE, "sys_module")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RAWIO, "sys_rawio")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_CHROOT, "sys_chroot")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PTRACE, "sys_ptrace")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PACCT, "sys_pacct")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_ADMIN, "sys_admin")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_BOOT, "sys_boot")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_NICE, "sys_nice")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RESOURCE, "sys_resource")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TIME, "sys_time")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TTY_CONFIG, "sys_tty_config")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__MKNOD, "mknod")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__LEASE, "lease")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_WRITE, "audit_write")
-    S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_CONTROL, "audit_control")
-    S_(SECCLASS_PASSWD, PASSWD__PASSWD, "passwd")
-    S_(SECCLASS_PASSWD, PASSWD__CHFN, "chfn")
-    S_(SECCLASS_PASSWD, PASSWD__CHSH, "chsh")
-    S_(SECCLASS_PASSWD, PASSWD__ROOTOK, "rootok")
-    S_(SECCLASS_PASSWD, PASSWD__CRONTAB, "crontab")
-    S_(SECCLASS_DRAWABLE, DRAWABLE__CREATE, "create")
-    S_(SECCLASS_DRAWABLE, DRAWABLE__DESTROY, "destroy")
-    S_(SECCLASS_DRAWABLE, DRAWABLE__DRAW, "draw")
-    S_(SECCLASS_DRAWABLE, DRAWABLE__COPY, "copy")
-    S_(SECCLASS_DRAWABLE, DRAWABLE__GETATTR, "getattr")
-    S_(SECCLASS_GC, GC__CREATE, "create")
-    S_(SECCLASS_GC, GC__FREE, "free")
-    S_(SECCLASS_GC, GC__GETATTR, "getattr")
-    S_(SECCLASS_GC, GC__SETATTR, "setattr")
-    S_(SECCLASS_WINDOW, WINDOW__ADDCHILD, "addchild")
-    S_(SECCLASS_WINDOW, WINDOW__CREATE, "create")
-    S_(SECCLASS_WINDOW, WINDOW__DESTROY, "destroy")
-    S_(SECCLASS_WINDOW, WINDOW__MAP, "map")
-    S_(SECCLASS_WINDOW, WINDOW__UNMAP, "unmap")
-    S_(SECCLASS_WINDOW, WINDOW__CHSTACK, "chstack")
-    S_(SECCLASS_WINDOW, WINDOW__CHPROPLIST, "chproplist")
-    S_(SECCLASS_WINDOW, WINDOW__CHPROP, "chprop")
-    S_(SECCLASS_WINDOW, WINDOW__LISTPROP, "listprop")
-    S_(SECCLASS_WINDOW, WINDOW__GETATTR, "getattr")
-    S_(SECCLASS_WINDOW, WINDOW__SETATTR, "setattr")
-    S_(SECCLASS_WINDOW, WINDOW__SETFOCUS, "setfocus")
-    S_(SECCLASS_WINDOW, WINDOW__MOVE, "move")
-    S_(SECCLASS_WINDOW, WINDOW__CHSELECTION, "chselection")
-    S_(SECCLASS_WINDOW, WINDOW__CHPARENT, "chparent")
-    S_(SECCLASS_WINDOW, WINDOW__CTRLLIFE, "ctrllife")
-    S_(SECCLASS_WINDOW, WINDOW__ENUMERATE, "enumerate")
-    S_(SECCLASS_WINDOW, WINDOW__TRANSPARENT, "transparent")
-    S_(SECCLASS_WINDOW, WINDOW__MOUSEMOTION, "mousemotion")
-    S_(SECCLASS_WINDOW, WINDOW__CLIENTCOMEVENT, "clientcomevent")
-    S_(SECCLASS_WINDOW, WINDOW__INPUTEVENT, "inputevent")
-    S_(SECCLASS_WINDOW, WINDOW__DRAWEVENT, "drawevent")
-    S_(SECCLASS_WINDOW, WINDOW__WINDOWCHANGEEVENT, "windowchangeevent")
-    S_(SECCLASS_WINDOW, WINDOW__WINDOWCHANGEREQUEST, "windowchangerequest")
-    S_(SECCLASS_WINDOW, WINDOW__SERVERCHANGEEVENT, "serverchangeevent")
-    S_(SECCLASS_WINDOW, WINDOW__EXTENSIONEVENT, "extensionevent")
-    S_(SECCLASS_FONT, FONT__LOAD, "load")
-    S_(SECCLASS_FONT, FONT__FREE, "free")
-    S_(SECCLASS_FONT, FONT__GETATTR, "getattr")
-    S_(SECCLASS_FONT, FONT__USE, "use")
-    S_(SECCLASS_COLORMAP, COLORMAP__CREATE, "create")
-    S_(SECCLASS_COLORMAP, COLORMAP__FREE, "free")
-    S_(SECCLASS_COLORMAP, COLORMAP__INSTALL, "install")
-    S_(SECCLASS_COLORMAP, COLORMAP__UNINSTALL, "uninstall")
-    S_(SECCLASS_COLORMAP, COLORMAP__LIST, "list")
-    S_(SECCLASS_COLORMAP, COLORMAP__READ, "read")
-    S_(SECCLASS_COLORMAP, COLORMAP__STORE, "store")
-    S_(SECCLASS_COLORMAP, COLORMAP__GETATTR, "getattr")
-    S_(SECCLASS_COLORMAP, COLORMAP__SETATTR, "setattr")
-    S_(SECCLASS_PROPERTY, PROPERTY__CREATE, "create")
-    S_(SECCLASS_PROPERTY, PROPERTY__FREE, "free")
-    S_(SECCLASS_PROPERTY, PROPERTY__READ, "read")
-    S_(SECCLASS_PROPERTY, PROPERTY__WRITE, "write")
-    S_(SECCLASS_CURSOR, CURSOR__CREATE, "create")
-    S_(SECCLASS_CURSOR, CURSOR__CREATEGLYPH, "createglyph")
-    S_(SECCLASS_CURSOR, CURSOR__FREE, "free")
-    S_(SECCLASS_CURSOR, CURSOR__ASSIGN, "assign")
-    S_(SECCLASS_CURSOR, CURSOR__SETATTR, "setattr")
-    S_(SECCLASS_XCLIENT, XCLIENT__KILL, "kill")
-    S_(SECCLASS_XINPUT, XINPUT__LOOKUP, "lookup")
-    S_(SECCLASS_XINPUT, XINPUT__GETATTR, "getattr")
-    S_(SECCLASS_XINPUT, XINPUT__SETATTR, "setattr")
-    S_(SECCLASS_XINPUT, XINPUT__SETFOCUS, "setfocus")
-    S_(SECCLASS_XINPUT, XINPUT__WARPPOINTER, "warppointer")
-    S_(SECCLASS_XINPUT, XINPUT__ACTIVEGRAB, "activegrab")
-    S_(SECCLASS_XINPUT, XINPUT__PASSIVEGRAB, "passivegrab")
-    S_(SECCLASS_XINPUT, XINPUT__UNGRAB, "ungrab")
-    S_(SECCLASS_XINPUT, XINPUT__BELL, "bell")
-    S_(SECCLASS_XINPUT, XINPUT__MOUSEMOTION, "mousemotion")
-    S_(SECCLASS_XINPUT, XINPUT__RELABELINPUT, "relabelinput")
-    S_(SECCLASS_XSERVER, XSERVER__SCREENSAVER, "screensaver")
-    S_(SECCLASS_XSERVER, XSERVER__GETHOSTLIST, "gethostlist")
-    S_(SECCLASS_XSERVER, XSERVER__SETHOSTLIST, "sethostlist")
-    S_(SECCLASS_XSERVER, XSERVER__GETFONTPATH, "getfontpath")
-    S_(SECCLASS_XSERVER, XSERVER__SETFONTPATH, "setfontpath")
-    S_(SECCLASS_XSERVER, XSERVER__GETATTR, "getattr")
-    S_(SECCLASS_XSERVER, XSERVER__GRAB, "grab")
-    S_(SECCLASS_XSERVER, XSERVER__UNGRAB, "ungrab")
-    S_(SECCLASS_XEXTENSION, XEXTENSION__QUERY, "query")
-    S_(SECCLASS_XEXTENSION, XEXTENSION__USE, "use")
-    S_(SECCLASS_PAX, PAX__PAGEEXEC, "pageexec")
-    S_(SECCLASS_PAX, PAX__EMUTRAMP, "emutramp")
-    S_(SECCLASS_PAX, PAX__MPROTECT, "mprotect")
-    S_(SECCLASS_PAX, PAX__RANDMMAP, "randmmap")
-    S_(SECCLASS_PAX, PAX__RANDEXEC, "randexec")
-    S_(SECCLASS_PAX, PAX__SEGMEXEC, "segmexec")
-    S_(SECCLASS_NETLINK_ROUTE_SOCKET, NETLINK_ROUTE_SOCKET__NLMSG_READ,
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__REMOUNT, "remount")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__UNMOUNT, "unmount")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__GETATTR, "getattr")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__RELABELFROM, "relabelfrom")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__RELABELTO, "relabelto")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__TRANSITION, "transition")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__ASSOCIATE, "associate")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAMOD, "quotamod")
+   S_(SECCLASS_FILESYSTEM, FILESYSTEM__QUOTAGET, "quotaget")
+   S_(SECCLASS_DIR, DIR__ADD_NAME, "add_name")
+   S_(SECCLASS_DIR, DIR__REMOVE_NAME, "remove_name")
+   S_(SECCLASS_DIR, DIR__REPARENT, "reparent")
+   S_(SECCLASS_DIR, DIR__SEARCH, "search")
+   S_(SECCLASS_DIR, DIR__RMDIR, "rmdir")
+   S_(SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, "execute_no_trans")
+   S_(SECCLASS_FILE, FILE__ENTRYPOINT, "entrypoint")
+   S_(SECCLASS_FILE, FILE__EXECMOD, "execmod")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__EXECUTE_NO_TRANS, "execute_no_trans")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__ENTRYPOINT, "entrypoint")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__EXECMOD, "execmod")
+   S_(SECCLASS_FD, FD__USE, "use")
+   S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__CONNECTTO, "connectto")
+   S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NEWCONN, "newconn")
+   S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__ACCEPTFROM, "acceptfrom")
+   S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NODE_BIND, "node_bind")
+   S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NAME_CONNECT, "name_connect")
+   S_(SECCLASS_UDP_SOCKET, UDP_SOCKET__NODE_BIND, "node_bind")
+   S_(SECCLASS_RAWIP_SOCKET, RAWIP_SOCKET__NODE_BIND, "node_bind")
+   S_(SECCLASS_NODE, NODE__TCP_RECV, "tcp_recv")
+   S_(SECCLASS_NODE, NODE__TCP_SEND, "tcp_send")
+   S_(SECCLASS_NODE, NODE__UDP_RECV, "udp_recv")
+   S_(SECCLASS_NODE, NODE__UDP_SEND, "udp_send")
+   S_(SECCLASS_NODE, NODE__RAWIP_RECV, "rawip_recv")
+   S_(SECCLASS_NODE, NODE__RAWIP_SEND, "rawip_send")
+   S_(SECCLASS_NODE, NODE__ENFORCE_DEST, "enforce_dest")
+   S_(SECCLASS_NODE, NODE__DCCP_RECV, "dccp_recv")
+   S_(SECCLASS_NODE, NODE__DCCP_SEND, "dccp_send")
+   S_(SECCLASS_NETIF, NETIF__TCP_RECV, "tcp_recv")
+   S_(SECCLASS_NETIF, NETIF__TCP_SEND, "tcp_send")
+   S_(SECCLASS_NETIF, NETIF__UDP_RECV, "udp_recv")
+   S_(SECCLASS_NETIF, NETIF__UDP_SEND, "udp_send")
+   S_(SECCLASS_NETIF, NETIF__RAWIP_RECV, "rawip_recv")
+   S_(SECCLASS_NETIF, NETIF__RAWIP_SEND, "rawip_send")
+   S_(SECCLASS_NETIF, NETIF__DCCP_RECV, "dccp_recv")
+   S_(SECCLASS_NETIF, NETIF__DCCP_SEND, "dccp_send")
+   S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__CONNECTTO, "connectto")
+   S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__NEWCONN, "newconn")
+   S_(SECCLASS_UNIX_STREAM_SOCKET, UNIX_STREAM_SOCKET__ACCEPTFROM, "acceptfrom")
+   S_(SECCLASS_PROCESS, PROCESS__FORK, "fork")
+   S_(SECCLASS_PROCESS, PROCESS__TRANSITION, "transition")
+   S_(SECCLASS_PROCESS, PROCESS__SIGCHLD, "sigchld")
+   S_(SECCLASS_PROCESS, PROCESS__SIGKILL, "sigkill")
+   S_(SECCLASS_PROCESS, PROCESS__SIGSTOP, "sigstop")
+   S_(SECCLASS_PROCESS, PROCESS__SIGNULL, "signull")
+   S_(SECCLASS_PROCESS, PROCESS__SIGNAL, "signal")
+   S_(SECCLASS_PROCESS, PROCESS__PTRACE, "ptrace")
+   S_(SECCLASS_PROCESS, PROCESS__GETSCHED, "getsched")
+   S_(SECCLASS_PROCESS, PROCESS__SETSCHED, "setsched")
+   S_(SECCLASS_PROCESS, PROCESS__GETSESSION, "getsession")
+   S_(SECCLASS_PROCESS, PROCESS__GETPGID, "getpgid")
+   S_(SECCLASS_PROCESS, PROCESS__SETPGID, "setpgid")
+   S_(SECCLASS_PROCESS, PROCESS__GETCAP, "getcap")
+   S_(SECCLASS_PROCESS, PROCESS__SETCAP, "setcap")
+   S_(SECCLASS_PROCESS, PROCESS__SHARE, "share")
+   S_(SECCLASS_PROCESS, PROCESS__GETATTR, "getattr")
+   S_(SECCLASS_PROCESS, PROCESS__SETEXEC, "setexec")
+   S_(SECCLASS_PROCESS, PROCESS__SETFSCREATE, "setfscreate")
+   S_(SECCLASS_PROCESS, PROCESS__NOATSECURE, "noatsecure")
+   S_(SECCLASS_PROCESS, PROCESS__SIGINH, "siginh")
+   S_(SECCLASS_PROCESS, PROCESS__SETRLIMIT, "setrlimit")
+   S_(SECCLASS_PROCESS, PROCESS__RLIMITINH, "rlimitinh")
+   S_(SECCLASS_PROCESS, PROCESS__DYNTRANSITION, "dyntransition")
+   S_(SECCLASS_PROCESS, PROCESS__SETCURRENT, "setcurrent")
+   S_(SECCLASS_PROCESS, PROCESS__EXECMEM, "execmem")
+   S_(SECCLASS_PROCESS, PROCESS__EXECSTACK, "execstack")
+   S_(SECCLASS_PROCESS, PROCESS__EXECHEAP, "execheap")
+   S_(SECCLASS_PROCESS, PROCESS__SETKEYCREATE, "setkeycreate")
+   S_(SECCLASS_PROCESS, PROCESS__SETSOCKCREATE, "setsockcreate")
+   S_(SECCLASS_MSGQ, MSGQ__ENQUEUE, "enqueue")
+   S_(SECCLASS_MSG, MSG__SEND, "send")
+   S_(SECCLASS_MSG, MSG__RECEIVE, "receive")
+   S_(SECCLASS_SHM, SHM__LOCK, "lock")
+   S_(SECCLASS_SECURITY, SECURITY__COMPUTE_AV, "compute_av")
+   S_(SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE, "compute_create")
+   S_(SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER, "compute_member")
+   S_(SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, "check_context")
+   S_(SECCLASS_SECURITY, SECURITY__LOAD_POLICY, "load_policy")
+   S_(SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL, "compute_relabel")
+   S_(SECCLASS_SECURITY, SECURITY__COMPUTE_USER, "compute_user")
+   S_(SECCLASS_SECURITY, SECURITY__SETENFORCE, "setenforce")
+   S_(SECCLASS_SECURITY, SECURITY__SETBOOL, "setbool")
+   S_(SECCLASS_SECURITY, SECURITY__SETSECPARAM, "setsecparam")
+   S_(SECCLASS_SECURITY, SECURITY__SETCHECKREQPROT, "setcheckreqprot")
+   S_(SECCLASS_SYSTEM, SYSTEM__IPC_INFO, "ipc_info")
+   S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_READ, "syslog_read")
+   S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_MOD, "syslog_mod")
+   S_(SECCLASS_SYSTEM, SYSTEM__SYSLOG_CONSOLE, "syslog_console")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__CHOWN, "chown")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__DAC_OVERRIDE, "dac_override")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__DAC_READ_SEARCH, "dac_read_search")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__FOWNER, "fowner")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__FSETID, "fsetid")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__KILL, "kill")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SETGID, "setgid")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SETUID, "setuid")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SETPCAP, "setpcap")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__LINUX_IMMUTABLE, "linux_immutable")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__NET_BIND_SERVICE, "net_bind_service")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__NET_BROADCAST, "net_broadcast")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__NET_ADMIN, "net_admin")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__NET_RAW, "net_raw")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__IPC_LOCK, "ipc_lock")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__IPC_OWNER, "ipc_owner")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_MODULE, "sys_module")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RAWIO, "sys_rawio")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_CHROOT, "sys_chroot")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PTRACE, "sys_ptrace")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PACCT, "sys_pacct")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_ADMIN, "sys_admin")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_BOOT, "sys_boot")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_NICE, "sys_nice")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RESOURCE, "sys_resource")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TIME, "sys_time")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TTY_CONFIG, "sys_tty_config")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__MKNOD, "mknod")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__LEASE, "lease")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_WRITE, "audit_write")
+   S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_CONTROL, "audit_control")
+   S_(SECCLASS_PASSWD, PASSWD__PASSWD, "passwd")
+   S_(SECCLASS_PASSWD, PASSWD__CHFN, "chfn")
+   S_(SECCLASS_PASSWD, PASSWD__CHSH, "chsh")
+   S_(SECCLASS_PASSWD, PASSWD__ROOTOK, "rootok")
+   S_(SECCLASS_PASSWD, PASSWD__CRONTAB, "crontab")
+   S_(SECCLASS_DRAWABLE, DRAWABLE__CREATE, "create")
+   S_(SECCLASS_DRAWABLE, DRAWABLE__DESTROY, "destroy")
+   S_(SECCLASS_DRAWABLE, DRAWABLE__DRAW, "draw")
+   S_(SECCLASS_DRAWABLE, DRAWABLE__COPY, "copy")
+   S_(SECCLASS_DRAWABLE, DRAWABLE__GETATTR, "getattr")
+   S_(SECCLASS_GC, GC__CREATE, "create")
+   S_(SECCLASS_GC, GC__FREE, "free")
+   S_(SECCLASS_GC, GC__GETATTR, "getattr")
+   S_(SECCLASS_GC, GC__SETATTR, "setattr")
+   S_(SECCLASS_WINDOW, WINDOW__ADDCHILD, "addchild")
+   S_(SECCLASS_WINDOW, WINDOW__CREATE, "create")
+   S_(SECCLASS_WINDOW, WINDOW__DESTROY, "destroy")
+   S_(SECCLASS_WINDOW, WINDOW__MAP, "map")
+   S_(SECCLASS_WINDOW, WINDOW__UNMAP, "unmap")
+   S_(SECCLASS_WINDOW, WINDOW__CHSTACK, "chstack")
+   S_(SECCLASS_WINDOW, WINDOW__CHPROPLIST, "chproplist")
+   S_(SECCLASS_WINDOW, WINDOW__CHPROP, "chprop")
+   S_(SECCLASS_WINDOW, WINDOW__LISTPROP, "listprop")
+   S_(SECCLASS_WINDOW, WINDOW__GETATTR, "getattr")
+   S_(SECCLASS_WINDOW, WINDOW__SETATTR, "setattr")
+   S_(SECCLASS_WINDOW, WINDOW__SETFOCUS, "setfocus")
+   S_(SECCLASS_WINDOW, WINDOW__MOVE, "move")
+   S_(SECCLASS_WINDOW, WINDOW__CHSELECTION, "chselection")
+   S_(SECCLASS_WINDOW, WINDOW__CHPARENT, "chparent")
+   S_(SECCLASS_WINDOW, WINDOW__CTRLLIFE, "ctrllife")
+   S_(SECCLASS_WINDOW, WINDOW__ENUMERATE, "enumerate")
+   S_(SECCLASS_WINDOW, WINDOW__TRANSPARENT, "transparent")
+   S_(SECCLASS_WINDOW, WINDOW__MOUSEMOTION, "mousemotion")
+   S_(SECCLASS_WINDOW, WINDOW__CLIENTCOMEVENT, "clientcomevent")
+   S_(SECCLASS_WINDOW, WINDOW__INPUTEVENT, "inputevent")
+   S_(SECCLASS_WINDOW, WINDOW__DRAWEVENT, "drawevent")
+   S_(SECCLASS_WINDOW, WINDOW__WINDOWCHANGEEVENT, "windowchangeevent")
+   S_(SECCLASS_WINDOW, WINDOW__WINDOWCHANGEREQUEST, "windowchangerequest")
+   S_(SECCLASS_WINDOW, WINDOW__SERVERCHANGEEVENT, "serverchangeevent")
+   S_(SECCLASS_WINDOW, WINDOW__EXTENSIONEVENT, "extensionevent")
+   S_(SECCLASS_FONT, FONT__LOAD, "load")
+   S_(SECCLASS_FONT, FONT__FREE, "free")
+   S_(SECCLASS_FONT, FONT__GETATTR, "getattr")
+   S_(SECCLASS_FONT, FONT__USE, "use")
+   S_(SECCLASS_COLORMAP, COLORMAP__CREATE, "create")
+   S_(SECCLASS_COLORMAP, COLORMAP__FREE, "free")
+   S_(SECCLASS_COLORMAP, COLORMAP__INSTALL, "install")
+   S_(SECCLASS_COLORMAP, COLORMAP__UNINSTALL, "uninstall")
+   S_(SECCLASS_COLORMAP, COLORMAP__LIST, "list")
+   S_(SECCLASS_COLORMAP, COLORMAP__READ, "read")
+   S_(SECCLASS_COLORMAP, COLORMAP__STORE, "store")
+   S_(SECCLASS_COLORMAP, COLORMAP__GETATTR, "getattr")
+   S_(SECCLASS_COLORMAP, COLORMAP__SETATTR, "setattr")
+   S_(SECCLASS_PROPERTY, PROPERTY__CREATE, "create")
+   S_(SECCLASS_PROPERTY, PROPERTY__FREE, "free")
+   S_(SECCLASS_PROPERTY, PROPERTY__READ, "read")
+   S_(SECCLASS_PROPERTY, PROPERTY__WRITE, "write")
+   S_(SECCLASS_CURSOR, CURSOR__CREATE, "create")
+   S_(SECCLASS_CURSOR, CURSOR__CREATEGLYPH, "createglyph")
+   S_(SECCLASS_CURSOR, CURSOR__FREE, "free")
+   S_(SECCLASS_CURSOR, CURSOR__ASSIGN, "assign")
+   S_(SECCLASS_CURSOR, CURSOR__SETATTR, "setattr")
+   S_(SECCLASS_XCLIENT, XCLIENT__KILL, "kill")
+   S_(SECCLASS_XINPUT, XINPUT__LOOKUP, "lookup")
+   S_(SECCLASS_XINPUT, XINPUT__GETATTR, "getattr")
+   S_(SECCLASS_XINPUT, XINPUT__SETATTR, "setattr")
+   S_(SECCLASS_XINPUT, XINPUT__SETFOCUS, "setfocus")
+   S_(SECCLASS_XINPUT, XINPUT__WARPPOINTER, "warppointer")
+   S_(SECCLASS_XINPUT, XINPUT__ACTIVEGRAB, "activegrab")
+   S_(SECCLASS_XINPUT, XINPUT__PASSIVEGRAB, "passivegrab")
+   S_(SECCLASS_XINPUT, XINPUT__UNGRAB, "ungrab")
+   S_(SECCLASS_XINPUT, XINPUT__BELL, "bell")
+   S_(SECCLASS_XINPUT, XINPUT__MOUSEMOTION, "mousemotion")
+   S_(SECCLASS_XINPUT, XINPUT__RELABELINPUT, "relabelinput")
+   S_(SECCLASS_XSERVER, XSERVER__SCREENSAVER, "screensaver")
+   S_(SECCLASS_XSERVER, XSERVER__GETHOSTLIST, "gethostlist")
+   S_(SECCLASS_XSERVER, XSERVER__SETHOSTLIST, "sethostlist")
+   S_(SECCLASS_XSERVER, XSERVER__GETFONTPATH, "getfontpath")
+   S_(SECCLASS_XSERVER, XSERVER__SETFONTPATH, "setfontpath")
+   S_(SECCLASS_XSERVER, XSERVER__GETATTR, "getattr")
+   S_(SECCLASS_XSERVER, XSERVER__GRAB, "grab")
+   S_(SECCLASS_XSERVER, XSERVER__UNGRAB, "ungrab")
+   S_(SECCLASS_XEXTENSION, XEXTENSION__QUERY, "query")
+   S_(SECCLASS_XEXTENSION, XEXTENSION__USE, "use")
+   S_(SECCLASS_PAX, PAX__PAGEEXEC, "pageexec")
+   S_(SECCLASS_PAX, PAX__EMUTRAMP, "emutramp")
+   S_(SECCLASS_PAX, PAX__MPROTECT, "mprotect")
+   S_(SECCLASS_PAX, PAX__RANDMMAP, "randmmap")
+   S_(SECCLASS_PAX, PAX__RANDEXEC, "randexec")
+   S_(SECCLASS_PAX, PAX__SEGMEXEC, "segmexec")
+   S_(SECCLASS_NETLINK_ROUTE_SOCKET, NETLINK_ROUTE_SOCKET__NLMSG_READ, 
    "nlmsg_read")
-    S_(SECCLASS_NETLINK_ROUTE_SOCKET, NETLINK_ROUTE_SOCKET__NLMSG_WRITE,
+   S_(SECCLASS_NETLINK_ROUTE_SOCKET, NETLINK_ROUTE_SOCKET__NLMSG_WRITE, 
    "nlmsg_write")
-    S_(SECCLASS_NETLINK_FIREWALL_SOCKET, NETLINK_FIREWALL_SOCKET__NLMSG_READ,
+   S_(SECCLASS_NETLINK_FIREWALL_SOCKET, NETLINK_FIREWALL_SOCKET__NLMSG_READ,
    "nlmsg_read")
-    S_(SECCLASS_NETLINK_FIREWALL_SOCKET, NETLINK_FIREWALL_SOCKET__NLMSG_WRITE,
+   S_(SECCLASS_NETLINK_FIREWALL_SOCKET, NETLINK_FIREWALL_SOCKET__NLMSG_WRITE,
    "nlmsg_write")
-    S_(SECCLASS_NETLINK_TCPDIAG_SOCKET, NETLINK_TCPDIAG_SOCKET__NLMSG_READ,
+   S_(SECCLASS_NETLINK_TCPDIAG_SOCKET, NETLINK_TCPDIAG_SOCKET__NLMSG_READ,
    "nlmsg_read")
-    S_(SECCLASS_NETLINK_TCPDIAG_SOCKET, NETLINK_TCPDIAG_SOCKET__NLMSG_WRITE,
+   S_(SECCLASS_NETLINK_TCPDIAG_SOCKET, NETLINK_TCPDIAG_SOCKET__NLMSG_WRITE, 
    "nlmsg_write")
-    S_(SECCLASS_NETLINK_XFRM_SOCKET, NETLINK_XFRM_SOCKET__NLMSG_READ, "nlmsg_read")
-    S_(SECCLASS_NETLINK_XFRM_SOCKET, NETLINK_XFRM_SOCKET__NLMSG_WRITE,
-   "nlmsg_write")
-    S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_READ,
+   S_(SECCLASS_NETLINK_XFRM_SOCKET, NETLINK_XFRM_SOCKET__NLMSG_READ, 
    "nlmsg_read")
-    S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_WRITE,
+   S_(SECCLASS_NETLINK_XFRM_SOCKET, NETLINK_XFRM_SOCKET__NLMSG_WRITE, 
    "nlmsg_write")
-    S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_RELAY,
-   "nlmsg_relay")
-    S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_READPRIV,
-   "nlmsg_readpriv")
-    S_(SECCLASS_NETLINK_IP6FW_SOCKET, NETLINK_IP6FW_SOCKET__NLMSG_READ,
+   S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_READ, 
    "nlmsg_read")
-    S_(SECCLASS_NETLINK_IP6FW_SOCKET, NETLINK_IP6FW_SOCKET__NLMSG_WRITE,
-   "nlmsg_write")
-    S_(SECCLASS_DBUS, DBUS__ACQUIRE_SVC, "acquire_svc")
-    S_(SECCLASS_DBUS, DBUS__SEND_MSG, "send_msg")
-    S_(SECCLASS_NSCD, NSCD__GETPWD, "getpwd")
-    S_(SECCLASS_NSCD, NSCD__GETGRP, "getgrp")
-    S_(SECCLASS_NSCD, NSCD__GETHOST, "gethost")
-    S_(SECCLASS_NSCD, NSCD__GETSTAT, "getstat")
-    S_(SECCLASS_NSCD, NSCD__ADMIN, "admin")
-    S_(SECCLASS_NSCD, NSCD__SHMEMPWD, "shmempwd")
-    S_(SECCLASS_NSCD, NSCD__SHMEMGRP, "shmemgrp")
-    S_(SECCLASS_NSCD, NSCD__SHMEMHOST, "shmemhost")
-    S_(SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, "sendto")
-    S_(SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, "recvfrom")
-    S_(SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, "setcontext")
-    S_(SECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, "polmatch")
-    S_(SECCLASS_PACKET, PACKET__SEND, "send")
-    S_(SECCLASS_PACKET, PACKET__RECV, "recv")
-    S_(SECCLASS_PACKET, PACKET__RELABELTO, "relabelto")
-    S_(SECCLASS_KEY, KEY__VIEW, "view")
-    S_(SECCLASS_KEY, KEY__READ, "read")
-    S_(SECCLASS_KEY, KEY__WRITE, "write")
-    S_(SECCLASS_KEY, KEY__SEARCH, "search")
-    S_(SECCLASS_KEY, KEY__LINK, "link")
-    S_(SECCLASS_KEY, KEY__SETATTR, "setattr")
-    S_(SECCLASS_KEY, KEY__CREATE, "create")
-    S_(SECCLASS_CONTEXT, CONTEXT__TRANSLATE, "translate")
-    S_(SECCLASS_CONTEXT, CONTEXT__CONTAINS, "contains")
+   S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_WRITE, "nlmsg_write")
+   S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_RELAY, "nlmsg_relay")
+   S_(SECCLASS_NETLINK_AUDIT_SOCKET, NETLINK_AUDIT_SOCKET__NLMSG_READPRIV, "nlmsg_readpriv")
+   S_(SECCLASS_NETLINK_IP6FW_SOCKET, NETLINK_IP6FW_SOCKET__NLMSG_READ, "nlmsg_read")
+   S_(SECCLASS_NETLINK_IP6FW_SOCKET, NETLINK_IP6FW_SOCKET__NLMSG_WRITE, "nlmsg_write")
+   S_(SECCLASS_DBUS, DBUS__ACQUIRE_SVC, "acquire_svc")
+   S_(SECCLASS_DBUS, DBUS__SEND_MSG, "send_msg")
+   S_(SECCLASS_NSCD, NSCD__GETPWD, "getpwd")
+   S_(SECCLASS_NSCD, NSCD__GETGRP, "getgrp")
+   S_(SECCLASS_NSCD, NSCD__GETHOST, "gethost")
+   S_(SECCLASS_NSCD, NSCD__GETSTAT, "getstat")
+   S_(SECCLASS_NSCD, NSCD__ADMIN, "admin")
+   S_(SECCLASS_NSCD, NSCD__SHMEMPWD, "shmempwd")
+   S_(SECCLASS_NSCD, NSCD__SHMEMGRP, "shmemgrp")
+   S_(SECCLASS_NSCD, NSCD__SHMEMHOST, "shmemhost")
+   S_(SECCLASS_NSCD, NSCD__GETSERV, "getserv")
+   S_(SECCLASS_NSCD, NSCD__SHMEMSERV, "shmemserv")
+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, "sendto")
+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, "recvfrom")
+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, "setcontext")
+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, "polmatch")
+   S_(SECCLASS_PACKET, PACKET__SEND, "send")
+   S_(SECCLASS_PACKET, PACKET__RECV, "recv")
+   S_(SECCLASS_PACKET, PACKET__RELABELTO, "relabelto")
+   S_(SECCLASS_PACKET, PACKET__FLOW_IN, "flow_in")
+   S_(SECCLASS_PACKET, PACKET__FLOW_OUT, "flow_out")
+   S_(SECCLASS_KEY, KEY__VIEW, "view")
+   S_(SECCLASS_KEY, KEY__READ, "read")
+   S_(SECCLASS_KEY, KEY__WRITE, "write")
+   S_(SECCLASS_KEY, KEY__SEARCH, "search")
+   S_(SECCLASS_KEY, KEY__LINK, "link")
+   S_(SECCLASS_KEY, KEY__SETATTR, "setattr")
+   S_(SECCLASS_KEY, KEY__CREATE, "create")
+   S_(SECCLASS_CONTEXT, CONTEXT__TRANSLATE, "translate")
+   S_(SECCLASS_CONTEXT, CONTEXT__CONTAINS, "contains")
+   S_(SECCLASS_DCCP_SOCKET, DCCP_SOCKET__NODE_BIND, "node_bind")
+   S_(SECCLASS_DCCP_SOCKET, DCCP_SOCKET__NAME_CONNECT, "name_connect")
+   S_(SECCLASS_MEMPROTECT, MEMPROTECT__MMAP_ZERO, "mmap_zero")
diff --exclude-from=exclude -N -u -r nsalibselinux/src/fgetfilecon.c libselinux-1.33.4/src/fgetfilecon.c
--- nsalibselinux/src/fgetfilecon.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/fgetfilecon.c	2010-07-19 19:36:18.000000000 +0200
@@ -37,6 +37,11 @@
 		ret = fgetxattr(fd, XATTR_NAME_SELINUX, buf, size - 1);
 	}
       out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = EOPNOTSUPP;
+		ret = -1;
+	}
 	if (ret < 0)
 		free(buf);
 	else
@@ -51,6 +56,8 @@
 	security_context_t rcontext;
 	int ret;
 
+	*context = NULL;
+
 	ret = fgetfilecon_raw(fd, &rcontext);
 
 	if (ret > 0) {
diff --exclude-from=exclude -N -u -r nsalibselinux/src/file_path_suffixes.h libselinux-1.33.4/src/file_path_suffixes.h
--- nsalibselinux/src/file_path_suffixes.h	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/file_path_suffixes.h	2010-07-20 14:28:07.643377731 +0200
@@ -16,5 +16,7 @@
     S_(SEUSERS, "/seusers")
     S_(TRANSLATIONS, "/setrans.conf")
     S_(NETFILTER_CONTEXTS, "/contexts/netfilter_contexts")
-    S_(FILE_CONTEXTS_HOMEDIR, "/contexts/files/file_contexts.homedir")
+    S_(FILE_CONTEXTS_HOMEDIR, "/contexts/files/file_contexts.homedirs")
     S_(FILE_CONTEXTS_LOCAL, "/contexts/files/file_contexts.local")
+    S_(VIRTUAL_DOMAIN, "/contexts/virtual_domain_context")
+    S_(VIRTUAL_IMAGE, "/contexts/virtual_image_context")
diff --exclude-from=exclude -N -u -r nsalibselinux/src/fsetfilecon.c libselinux-1.33.4/src/fsetfilecon.c
--- nsalibselinux/src/fsetfilecon.c	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/src/fsetfilecon.c	2010-07-19 19:36:18.000000000 +0200
@@ -13,7 +13,7 @@
 			 0);
 }
 
-hidden_def(setfilecon_raw)
+hidden_def(fsetfilecon_raw)
 
 int fsetfilecon(int fd, security_context_t context)
 {
diff --exclude-from=exclude -N -u -r nsalibselinux/src/getfilecon.c libselinux-1.33.4/src/getfilecon.c
--- nsalibselinux/src/getfilecon.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/getfilecon.c	2010-07-19 19:36:18.000000000 +0200
@@ -37,6 +37,11 @@
 		ret = getxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
 	}
       out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = EOPNOTSUPP;
+		ret = -1;
+	}
 	if (ret < 0)
 		free(buf);
 	else
@@ -51,6 +56,8 @@
 	int ret;
 	security_context_t rcontext;
 
+	*context = NULL;
+
 	ret = getfilecon_raw(path, &rcontext);
 
 	if (ret > 0) {
diff --exclude-from=exclude -N -u -r nsalibselinux/src/init.c libselinux-1.33.4/src/init.c
--- nsalibselinux/src/init.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/init.c	2010-11-16 12:18:46.903149261 +0100
@@ -90,5 +90,5 @@
 static void fini_lib(void)
 {
 	fini_selinuxmnt();
-	fini_context_translations();
+//	fini_context_translations()
 }
diff --exclude-from=exclude -N -u -r nsalibselinux/src/lgetfilecon.c libselinux-1.33.4/src/lgetfilecon.c
--- nsalibselinux/src/lgetfilecon.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/lgetfilecon.c	2010-07-19 19:36:18.000000000 +0200
@@ -37,6 +37,11 @@
 		ret = lgetxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
 	}
       out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = EOPNOTSUPP;
+		ret = -1;
+	}
 	if (ret < 0)
 		free(buf);
 	else
@@ -51,6 +56,8 @@
 	int ret;
 	security_context_t rcontext;
 
+	*context = NULL;
+
 	ret = lgetfilecon_raw(path, &rcontext);
 
 	if (ret > 0) {
diff --exclude-from=exclude -N -u -r nsalibselinux/src/Makefile libselinux-1.33.4/src/Makefile
--- nsalibselinux/src/Makefile	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/Makefile	2010-07-19 19:36:18.000000000 +0200
@@ -7,21 +7,33 @@
 PYINC ?= /usr/include/$(PYLIBVER)
 PYLIB ?= /usr/lib/$(PYLIBVER)
 PYTHONLIBDIR ?= $(LIBDIR)/$(PYLIBVER)
+RUBYLIBVER ?= $(shell ruby -e 'print RUBY_VERSION.split(".")[0..1].join(".")')
+RUBYPLATFORM ?= $(shell ruby -e 'print RUBY_PLATFORM')
+RUBYINC ?= $(LIBDIR)/ruby/$(RUBYLIBVER)/$(RUBYPLATFORM)
+RUBYINSTALL ?= $(LIBDIR)/ruby/site_ruby/$(RUBYLIBVER)/$(RUBYPLATFORM)
 
 LIBVERSION = 1
 
 LIBA=libselinux.a 
 TARGET=libselinux.so
-SWIGIF= selinuxswig.i
+SWIGIF= selinuxswig_python.i
+SWIGRUBYIF= selinuxswig_ruby.i
 SWIGCOUT= selinuxswig_wrap.c
+SWIGRUBYCOUT= selinuxswig_ruby_wrap.c
 SWIGLOBJ:= $(patsubst %.c,%.lo,$(SWIGCOUT)) 
+SWIGRUBYLOBJ:= $(patsubst %.c,%.lo,$(SWIGRUBYCOUT)) 
 SWIGSO=_selinux.so
 SWIGFILES=$(SWIGSO) selinux.py 
+SWIGRUBYSO=_rubyselinux.so
 LIBSO=$(TARGET).$(LIBVERSION)
-OBJS= $(patsubst %.c,%.o,$(filter-out $(SWIGCOUT),$(wildcard *.c))) 
-LOBJS= $(patsubst %.c,%.lo,$(filter-out $(SWIGCOUT),$(wildcard *.c)))
-CFLAGS ?= -Wall -W -Wundef -Wmissing-noreturn -Wmissing-format-attribute
-override CFLAGS += -I../include -I$(INCLUDEDIR) -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
+
+GENERATED=$(SWIGCOUT) $(SWIGRUBYCOUT)
+SRCS= $(filter-out $(UNUSED_SRCS), $(filter-out $(GENERATED),$(wildcard *.c)))
+
+OBJS= $(patsubst %.c,%.o,$(SRCS))
+LOBJS= $(patsubst %.c,%.lo,$(SRCS))
+CFLAGS ?= -Werror -Wall -W -Wundef -Wshadow -Wmissing-noreturn -Wmissing-format-attribute
+override CFLAGS += -I../include -I$(INCLUDEDIR) -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 $(EMFLAGS)
 RANLIB=ranlib
 
 ARCH := $(patsubst i%86,i386,$(shell uname -m))
@@ -31,24 +43,32 @@
 
 SWIG = swig -Wall -python -o $(SWIGCOUT) -outdir ./
 
-GENERATED=$(SWIGCOUT)
+SWIGRUBY = swig -Wall -ruby -o $(SWIGRUBYCOUT) -outdir ./
 
 all: $(LIBA) $(LIBSO) 
 
 pywrap: all $(SWIGSO)
 
+rubywrap: all $(SWIGRUBYSO)
+
 $(LIBA):  $(OBJS)
 	$(AR) rcs $@ $^
 	$(RANLIB) $@
 
 $(SWIGLOBJ): $(SWIGCOUT)
-	$(CC) $(CFLAGS) -I$(PYINC) -fPIC -DSHARED -c -o $@ $<
+	$(CC) $(filter-out -Werror,$(CFLAGS)) -I$(PYINC) -fPIC -DSHARED -c -o $@ $<
+
+$(SWIGRUBYLOBJ): $(SWIGRUBYCOUT)
+	$(CC) $(filter-out -Werror,$(CFLAGS)) -I$(RUBYINC) -fPIC -DSHARED -c -o $@ $<
 
 $(SWIGSO): $(SWIGLOBJ)
-	$(CC) $(LDFLAGS) -shared -o $@ $< -L. -lselinux -L$(LIBDIR) -Wl,-soname,$@
+	$(CC) $(CFLAGS) $(LDFLAGS) -shared -o $@ $< -L. -lselinux -L$(LIBDIR) -Wl,-soname,$@
+
+$(SWIGRUBYSO): $(SWIGRUBYLOBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -shared -o $@ $^ -L. -lselinux -L$(LIBDIR) -Wl,-soname,$@
 
 $(LIBSO): $(LOBJS)
-	$(CC) $(LDFLAGS) -shared -o $@ $^ -ldl -lsepol -L$(LIBDIR) -Wl,-soname,$(LIBSO),-z,defs,-z,relro
+	$(CC) $(CFLAGS) $(LDFLAGS) -shared -o $@ $^ -ldl -lsepol -L$(LIBDIR) -Wl,-soname,$(LIBSO),-z,defs,-z,relro
 	ln -sf $@ $(TARGET) 
 
 %.o:  %.c policy.h
@@ -60,6 +80,9 @@
 $(SWIGCOUT): $(SWIGIF)
 	$(SWIG) $^
 
+$(SWIGRUBYCOUT): $(SWIGRUBYIF)
+	$(SWIGRUBY) $^
+
 swigify: $(SWIGIF)
 	$(SWIG) $^
 
@@ -71,18 +94,23 @@
 	cd $(LIBDIR) && ln -sf ../../`basename $(SHLIBDIR)`/$(LIBSO) $(TARGET)
 
 install-pywrap: pywrap
-	test -d $(PYTHONLIBDIR)/site-packages || install -m 755 -d $(PYTHONLIBDIR)/site-packages
-	install -m 755 $(SWIGFILES) $(PYTHONLIBDIR)/site-packages
+	test -d $(PYTHONLIBDIR)/site-packages/selinux || install -m 755 -d $(PYTHONLIBDIR)/site-packages/selinux
+	install -m 755 $(SWIGSO) $(PYTHONLIBDIR)/site-packages/selinux
+	install -m 644  selinux.py $(PYTHONLIBDIR)/site-packages/selinux/__init__.py
+
+install-rubywrap: rubywrap
+	test -d $(RUBYINSTALL) || install -m 755 -d $(RUBYINSTALL) 
+	install -m 755 $(SWIGRUBYSO) $(RUBYINSTALL)/selinux.so
 
 relabel:
 	/sbin/restorecon $(SHLIBDIR)/$(LIBSO)
 
 clean: 
-	-rm -f $(OBJS) $(LOBJS) $(LIBA) $(LIBSO) $(SWIGLOBJ) $(SWIGSO) $(TARGET) 
+	-rm -f $(OBJS) $(LOBJS) $(LIBA) $(LIBSO) $(SWIGLOBJ) $(SWIGSO) $(TARGET) *.o *.lo *~
 
 distclean: clean
-	rm -f $(SWIGCOUT) $(SWIGFILES)
+	rm -f $(GENERATED) $(SWIGFILES)
 
 indent:
-	../../Lindent $(filter-out $(GENERATED),$(wildcard *.[ch]))
+	../../scripts/Lindent $(filter-out $(GENERATED),$(wildcard *.[ch]))
 
diff --exclude-from=exclude -N -u -r nsalibselinux/src/matchpathcon.c libselinux-1.33.4/src/matchpathcon.c
--- nsalibselinux/src/matchpathcon.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/matchpathcon.c	2010-07-19 19:36:18.000000000 +0200
@@ -6,6 +6,7 @@
 #include <stdio.h>
 #include <stdio_ext.h>
 #include <stdlib.h>
+#include <syslog.h>
 #include <ctype.h>
 #include <errno.h>
 #include <limits.h>
@@ -22,7 +23,7 @@
 {
 	va_list ap;
 	va_start(ap, fmt);
-	vfprintf(stderr, fmt, ap);
+	vsyslog(LOG_ERR, fmt, ap);
 	va_end(ap);
 }
 
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinux_config.c libselinux-1.33.4/src/selinux_config.c
--- nsalibselinux/src/selinux_config.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/selinux_config.c	2010-07-20 09:22:15.000000000 +0200
@@ -39,7 +39,9 @@
 #define FILE_CONTEXTS_HOMEDIR 16
 #define FILE_CONTEXTS_LOCAL 17
 #define SECURETTY_TYPES   18
-#define NEL               19
+#define VIRTUAL_DOMAIN    19
+#define VIRTUAL_IMAGE     20
+#define NEL               21
 
 /* New layout is relative to SELINUXDIR/policytype. */
 static char *file_paths[NEL];
@@ -416,3 +418,17 @@
 }
 
 hidden_def(selinux_file_context_local_path)
+
+const char *selinux_virtual_domain_context_path()
+{
+        return get_path(VIRTUAL_DOMAIN);
+}
+
+hidden_def(selinux_virtual_domain_context_path)
+
+const char *selinux_virtual_image_context_path()
+{
+        return get_path(VIRTUAL_IMAGE);
+}
+
+hidden_def(selinux_virtual_image_context_path)
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinux_internal.h libselinux-1.33.4/src/selinux_internal.h
--- nsalibselinux/src/selinux_internal.h	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/selinux_internal.h	2010-07-19 19:39:53.000000000 +0200
@@ -56,6 +56,8 @@
     hidden_proto(selinux_securetty_types_path)
     hidden_proto(selinux_failsafe_context_path)
     hidden_proto(selinux_removable_context_path)
+    hidden_proto(selinux_virtual_domain_context_path)
+    hidden_proto(selinux_virtual_image_context_path)
     hidden_proto(selinux_file_context_path)
     hidden_proto(selinux_file_context_homedir_path)
     hidden_proto(selinux_file_context_local_path)
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinux.py libselinux-1.33.4/src/selinux.py
--- nsalibselinux/src/selinux.py	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/selinux.py	2010-07-19 19:36:18.000000000 +0200
@@ -1,10 +1,16 @@
-# This file was created automatically by SWIG 1.3.29.
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 1.3.31
+#
 # Don't modify this file, modify the SWIG interface instead.
 # This file is compatible with both classic and new-style classes.
 
 import _selinux
 import new
 new_instancemethod = new.instancemethod
+try:
+    _swig_property = property
+except NameError:
+    pass # Python < 2.2 doesn't have 'property'.
 def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
     if (name == "thisown"): return self.this.own(value)
     if (name == "this"):
@@ -42,8 +48,19 @@
 del types
 
 
+SELINUX_DEFAULTUSER = _selinux.SELINUX_DEFAULTUSER
+get_ordered_context_list = _selinux.get_ordered_context_list
+get_ordered_context_list_with_level = _selinux.get_ordered_context_list_with_level
+get_default_context = _selinux.get_default_context
+get_default_context_with_level = _selinux.get_default_context_with_level
+get_default_context_with_role = _selinux.get_default_context_with_role
+get_default_context_with_rolelevel = _selinux.get_default_context_with_rolelevel
+query_user_context = _selinux.query_user_context
+manual_user_enter_context = _selinux.manual_user_enter_context
 is_selinux_enabled = _selinux.is_selinux_enabled
 is_selinux_mls_enabled = _selinux.is_selinux_mls_enabled
+freecon = _selinux.freecon
+freeconary = _selinux.freeconary
 getcon = _selinux.getcon
 setcon = _selinux.setcon
 getpidcon = _selinux.getpidcon
@@ -82,6 +99,8 @@
 set_matchpathcon_flags = _selinux.set_matchpathcon_flags
 matchpathcon_init = _selinux.matchpathcon_init
 matchpathcon = _selinux.matchpathcon
+matchpathcon_init_prefix = _selinux.matchpathcon_init_prefix
+matchpathcon_fini = _selinux.matchpathcon_fini
 matchmediacon = _selinux.matchmediacon
 selinux_getenforcemode = _selinux.selinux_getenforcemode
 selinux_policy_root = _selinux.selinux_policy_root
@@ -96,6 +115,7 @@
 selinux_homedir_context_path = _selinux.selinux_homedir_context_path
 selinux_media_context_path = _selinux.selinux_media_context_path
 selinux_contexts_path = _selinux.selinux_contexts_path
+selinux_securetty_types_path = _selinux.selinux_securetty_types_path
 selinux_booleans_path = _selinux.selinux_booleans_path
 selinux_customizable_types_path = _selinux.selinux_customizable_types_path
 selinux_users_path = _selinux.selinux_users_path
@@ -103,13 +123,16 @@
 selinux_translations_path = _selinux.selinux_translations_path
 selinux_netfilter_context_path = _selinux.selinux_netfilter_context_path
 selinux_path = _selinux.selinux_path
-selinux_check_passwd_access = _selinux.selinux_check_passwd_access
-checkPasswdAccess = _selinux.checkPasswdAccess
+selinux_check_securetty_context = _selinux.selinux_check_securetty_context
+set_selinuxmnt = _selinux.set_selinuxmnt
 rpm_execcon = _selinux.rpm_execcon
 is_context_customizable = _selinux.is_context_customizable
 selinux_trans_to_raw_context = _selinux.selinux_trans_to_raw_context
 selinux_raw_to_trans_context = _selinux.selinux_raw_to_trans_context
 selinux_getpolicytype = _selinux.selinux_getpolicytype
 getseuserbyname = _selinux.getseuserbyname
+selinux_file_context_cmp = _selinux.selinux_file_context_cmp
+selinux_file_context_verify = _selinux.selinux_file_context_verify
+selinux_lsetfilecon_default = _selinux.selinux_lsetfilecon_default
 
 
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinuxswig.i libselinux-1.33.4/src/selinuxswig.i
--- nsalibselinux/src/selinuxswig.i	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/src/selinuxswig.i	2010-07-19 19:36:18.000000000 +0200
@@ -1,137 +1,53 @@
-/* Author: Dan Walsh
- *
- * Copyright (C) 2004-2005 Red Hat
- * 
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2.1 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+/* Authors: Dan Walsh
+ *          James Athey
  */
 
-
 %module selinux
 %{
 	#include "selinux/selinux.h"
+	#include "../include/selinux/selinux.h"
+	#include "../include/selinux/get_default_type.h"
+	#include "../include/selinux/get_context_list.h"
 %}
-%apply int *OUTPUT { int * };
+%apply int *OUTPUT { int *enforce };
 %apply int *OUTPUT { size_t * };
 
-%typemap(in, numinputs=0) security_context_t *(security_context_t temp) {
-	$1 = &temp;
-}
-%typemap(argout) security_context_t * (char *temp) {
-	if (*$1)
-		temp = *$1;
-	else
-		temp = "";
-	$result = SWIG_Python_AppendOutput($result, PyString_FromString(temp));
-}
+%typedef unsigned mode_t;
+%typedef unsigned pid_t;
 
-%typemap(in) security_context_t {
-	$1 = (security_context_t)PyString_AsString($input);
+%typemap(in, numinputs=0) (char ***names, int *len) (char **temp1, int temp2) {
+	$1 = &temp1;
+	$2 = &temp2;
 }
 
-%typedef unsigned mode_t;
-
-extern int is_selinux_enabled(void);
-extern int is_selinux_mls_enabled(void);
-extern int getcon(security_context_t *con);
-extern int setcon(security_context_t con);
-extern int getpidcon(int pid, security_context_t *con);
-extern int getprevcon(security_context_t *con);
-extern int getexeccon(security_context_t *con);
-extern int setexeccon(security_context_t con);
-extern int getfscreatecon(security_context_t *con);
-extern int setfscreatecon(security_context_t context);
-extern int getkeycreatecon(security_context_t *con);
-extern int setkeycreatecon(security_context_t context);
-extern int getsockcreatecon(security_context_t *con);
-extern int setsockcreatecon(security_context_t context);
-extern int getfilecon(const char *path, security_context_t *con);
-extern int lgetfilecon(const char *path, security_context_t *con);
-extern int fgetfilecon(int fd, security_context_t *con);
-extern int setfilecon(const char *path, security_context_t con);
-extern int lsetfilecon(const char *path, security_context_t con);
-extern int fsetfilecon(int fd, security_context_t con);
-extern int getpeercon(int fd, security_context_t *con);
-extern int selinux_mkload_policy(int preservebools);
-extern int selinux_init_load_policy(int *enforce);
-extern int security_set_boolean_list(size_t boolcnt, 
-				     SELboolean *boollist, 
-				     int permanent);
-extern int security_load_booleans(char *path);
-extern int security_check_context(security_context_t con);
-extern int security_canonicalize_context(security_context_t con,
-					 security_context_t *canoncon);
-extern int security_getenforce(void);
-extern int security_setenforce(int value);
-extern int security_policyvers(void);
-extern int security_get_boolean_names(char ***names, int *len);
-extern int security_get_boolean_pending(const char *name);
-extern int security_get_boolean_active(const char *name);
-extern int security_set_boolean(const char *name, int value);
-extern int security_commit_booleans(void);
-
-/* Set flags controlling operation of matchpathcon_init or matchpathcon. */
-#define MATCHPATHCON_BASEONLY 1 /* Only process the base file_contexts file. */
-#define MATCHPATHCON_NOTRANS  2 /* Do not perform any context translation. */
-extern void set_matchpathcon_flags(unsigned int flags);
-extern int matchpathcon_init(const char *path);
-extern int matchpathcon(const char *path,
-			mode_t mode,
-			security_context_t *con);
-
-extern int matchmediacon(const char *media,
-		 security_context_t *con);
-
-extern int selinux_getenforcemode(int *enforce);
-extern const char *selinux_policy_root(void);
-extern const char *selinux_binary_policy_path(void);
-extern const char *selinux_failsafe_context_path(void);
-extern const char *selinux_removable_context_path(void);
-extern const char *selinux_default_context_path(void);
-extern const char *selinux_user_contexts_path(void);
-extern const char *selinux_file_context_path(void);
-extern const char *selinux_file_context_homedir_path(void);
-extern const char *selinux_file_context_local_path(void);
-extern const char *selinux_homedir_context_path(void);
-extern const char *selinux_media_context_path(void);
-extern const char *selinux_contexts_path(void);
-extern const char *selinux_booleans_path(void);
-extern const char *selinux_customizable_types_path(void);
-extern const char *selinux_users_path(void);
-extern const char *selinux_usersconf_path(void);
-extern const char *selinux_translations_path(void);
-extern const char *selinux_netfilter_context_path(void);
-extern const char *selinux_path(void);
-extern int selinux_check_passwd_access(access_vector_t requested);
-extern int checkPasswdAccess(access_vector_t requested);
-extern int rpm_execcon(unsigned int verified, 
-		       const char *filename, 
-		       char *const argv[], char *const envp[]);
-
-extern int is_context_customizable (security_context_t scontext);
-
-extern int selinux_trans_to_raw_context(char *trans, 
-					security_context_t *rawp);
-extern int selinux_raw_to_trans_context(char *raw, 
-					security_context_t *transp);
+%typemap(freearg) (char ***names, int *len) {
+	int i;
+	if (*$1) {
+		for (i = 0; i < *$2; i++) {
+			free((*$1)[i]);
+		}
+		free(*$1);
+	}
+}
 
-%typemap(in, numinputs=0) char **(char *temp) {
+%typemap(in, numinputs=0) (security_context_t **) (security_context_t *temp) {
 	$1 = &temp;
 }
 
-%typemap(argout) char ** {
-	$result = SWIG_Python_AppendOutput($result, PyString_FromString(*$1));
+%typemap(freearg) (security_context_t **) {
+	if (*$1) freeconary(*$1);
 }
-extern int selinux_getpolicytype(char **enforce);
-extern int getseuserbyname(const char *linuxuser, char **seuser, char **level);
+
+/* Ignore functions that don't make sense when wrapped */
+%ignore freecon;
+%ignore freeconary;
+
+/* Ignore functions that take a function pointer as an argument */
+%ignore set_matchpathcon_printf;
+%ignore set_matchpathcon_invalidcon;
+%ignore set_matchpathcon_canoncon;
+
+%include "../include/selinux/selinux.h"
+%include "../include/selinux/get_default_type.h"
+%include "../include/selinux/get_context_list.h"
+
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinuxswig_python.i libselinux-1.33.4/src/selinuxswig_python.i
--- nsalibselinux/src/selinuxswig_python.i	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/src/selinuxswig_python.i	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,162 @@
+/* Author: James Athey
+ */
+
+%module selinux
+%{
+	#include "selinux/selinux.h"
+%}
+
+%pythoncode %{
+
+import shutil, os, stat
+
+def restorecon(path, recursive=False):
+    """ Restore SELinux context on a given path """
+    mode = os.stat(path)[stat.ST_MODE]
+    status, context = matchpathcon(path, mode)
+    if status == 0:
+        lsetfilecon(path, context)
+        if recursive:
+            os.path.walk(path, lambda arg, dirname, fnames:
+                             map(restorecon, [os.path.join(dirname, fname)
+                                              for fname in fnames]), None)
+
+def copytree(src, dest):
+    """ An SELinux-friendly shutil.copytree method """
+    shutil.copytree(src, dest)
+    restorecon(dest, recursive=True)
+
+def install(src, dest):
+    """ An SELinux-friendly shutil.move method """
+    shutil.move(src, dest)
+    restorecon(dest, recursive=True)
+%}
+
+/* security_get_boolean_names() typemap */
+%typemap(argout) (char ***names, int *len) {
+	PyObject* list = PyList_New(*$2);
+	int i;
+	for (i = 0; i < *$2; i++) {
+		PyList_SetItem(list, i, PyString_FromString((*$1)[i]));
+	}
+	$result = SWIG_Python_AppendOutput($result, list);
+}
+
+/* return a sid along with the result */
+%typemap(argout) (security_id_t * sid) {
+	if (*$1) {
+                %append_output(SWIG_NewPointerObj(*$1, $descriptor(security_id_t), 0));
+	} else {
+		Py_INCREF(Py_None);
+		%append_output(Py_None);
+	}
+}
+
+%typemap(in,numinputs=0) security_id_t *(security_id_t temp) {
+  $1 = &temp;
+}
+
+/* Makes security_compute_user() return a Python list of contexts */
+%typemap(argout) (security_context_t **con) {
+	PyObject* plist;
+	int i, len = 0;
+	
+	if (*$1) {
+		while((*$1)[len])
+			len++;
+		plist = PyList_New(len);
+		for (i = 0; i < len; i++) {
+			PyList_SetItem(plist, i, PyString_FromString((*$1)[i]));
+		}
+	} else {
+		plist = PyList_New(0);
+	}
+
+	$result = SWIG_Python_AppendOutput($result, plist);
+}
+
+/* Makes functions in get_context_list.h return a Python list of contexts */
+%typemap(argout) (security_context_t **list) {
+	PyObject* plist;
+	int i;
+	
+	if (*$1) {
+		plist = PyList_New(result);
+		for (i = 0; i < result; i++) {
+			PyList_SetItem(plist, i, PyString_FromString((*$1)[i]));
+		}
+	} else {
+		plist = PyList_New(0);
+	}
+	/* Only return the Python list, don't need to return the length anymore */
+	$result = plist;
+}
+
+%typemap(in,noblock=1,numinputs=0) security_context_t * (security_context_t temp = 0) {
+	$1 = &temp;
+}
+%typemap(freearg,match="in") security_context_t * "";
+%typemap(argout,noblock=1) security_context_t * {
+	if (*$1) {
+		%append_output(SWIG_FromCharPtr(*$1));
+		freecon(*$1);
+	}
+	else {
+		Py_INCREF(Py_None);
+		%append_output(Py_None);
+	}
+}
+
+%typemap(in,noblock=1,numinputs=0) char ** (char * temp = 0) {
+	$1 = &temp;
+}
+%typemap(freearg,match="in") char ** "";
+%typemap(argout,noblock=1) char ** {
+	if (*$1) {
+		%append_output(SWIG_FromCharPtr(*$1));
+		free(*$1);
+	}
+	else {
+		Py_INCREF(Py_None);
+		%append_output(Py_None);
+	}
+}
+
+%typemap(in) char * const [] {
+	int i, size;
+	PyObject * s;
+
+	if (!PySequence_Check($input)) {
+		PyErr_SetString(PyExc_ValueError, "Expected a sequence");
+		return NULL;
+	}
+
+	size = PySequence_Size($input);
+	
+	$1 = (char**) malloc(size + 1);
+
+	for(i = 0; i < size; i++) {
+		if (!PyString_Check(PySequence_GetItem($input, i))) {
+			PyErr_SetString(PyExc_ValueError, "Sequence must contain only strings");
+			return NULL;
+		}
+	}
+		
+	for(i = 0; i < size; i++) {
+		s = PySequence_GetItem($input, i);
+		$1[i] = (char*) malloc(PyString_Size(s) + 1);
+		strcpy($1[i], PyString_AsString(s));
+	}
+	$1[size] = NULL;
+}
+
+%typemap(freearg,match="in") char * const [] {
+	int i = 0;
+	while($1[i]) {
+		free($1[i]);
+		i++;
+	}
+	free($1);
+}
+
+%include "selinuxswig.i"
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinuxswig_ruby.i libselinux-1.33.4/src/selinuxswig_ruby.i
--- nsalibselinux/src/selinuxswig_ruby.i	1970-01-01 01:00:00.000000000 +0100
+++ libselinux-1.33.4/src/selinuxswig_ruby.i	2010-07-19 19:36:18.000000000 +0200
@@ -0,0 +1,52 @@
+/* Author: Dan Walsh
+   Based on selinuxswig_python.i by James Athey
+ */
+
+%module selinux
+%{
+	#include "selinux/selinux.h"
+%}
+
+/* return a sid along with the result */
+%typemap(argout) (security_id_t * sid) {
+	if (*$1) {
+                %append_output(SWIG_NewPointerObj(*$1, $descriptor(security_id_t), 0));
+	} 
+}
+
+%typemap(in,numinputs=0) security_id_t *(security_id_t temp) {
+  $1 = &temp;
+}
+
+%typemap(in,noblock=1,numinputs=0) security_context_t * (security_context_t temp = 0) {
+	$1 = &temp;
+}
+%typemap(freearg,match="in") security_context_t * "";
+%typemap(argout,noblock=1) security_context_t * {
+	if (*$1) {
+		%append_output(SWIG_FromCharPtr(*$1));
+		freecon(*$1);
+	}
+}
+
+%typemap(in,noblock=1,numinputs=0) char ** (char * temp = 0) {
+	$1 = &temp;
+}
+%typemap(freearg,match="in") char ** "";
+%typemap(argout,noblock=1) char ** {
+	if (*$1) {
+		%append_output(SWIG_FromCharPtr(*$1));
+		free(*$1);
+	}
+}
+
+%typemap(freearg,match="in") char * const [] {
+	int i = 0;
+	while($1[i]) {
+		free($1[i]);
+		i++;
+	}
+	free($1);
+}
+
+%include "selinuxswig.i"
diff --exclude-from=exclude -N -u -r nsalibselinux/src/selinuxswig_wrap.c libselinux-1.33.4/src/selinuxswig_wrap.c
--- nsalibselinux/src/selinuxswig_wrap.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/selinuxswig_wrap.c	2010-07-19 19:36:19.000000000 +0200
@@ -1,6 +1,6 @@
 /* ----------------------------------------------------------------------------
  * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 1.3.29
+ * Version 1.3.35
  * 
  * This file is not intended to be easily readable and contains a number of 
  * coding conventions designed to improve portability and efficiency. Do not make
@@ -17,14 +17,14 @@
 
 /* template workaround for compilers that cannot correctly implement the C++ standard */
 #ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC)
-#   if (__SUNPRO_CC <= 0x560)
-#     define SWIGTEMPLATEDISAMBIGUATOR template
-#   else
-#     define SWIGTEMPLATEDISAMBIGUATOR 
-#   endif
+# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
+#  define SWIGTEMPLATEDISAMBIGUATOR template
 # else
-#   define SWIGTEMPLATEDISAMBIGUATOR 
+#  define SWIGTEMPLATEDISAMBIGUATOR
 # endif
 #endif
 
@@ -103,10 +103,16 @@
 #endif
 
 /* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
 # define _CRT_SECURE_NO_DEPRECATE
 #endif
 
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
 
 /* Python.h has to appear first */
 #include <Python.h>
@@ -120,7 +126,7 @@
 
 /* This should only be incremented when either the layout of swig_type_info changes,
    or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "2"
+#define SWIG_RUNTIME_VERSION "4"
 
 /* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
 #ifdef SWIG_TYPE_TABLE
@@ -155,6 +161,7 @@
 
 /* Flags for pointer conversions */
 #define SWIG_POINTER_DISOWN        0x1
+#define SWIG_CAST_NEW_MEMORY       0x2
 
 /* Flags for new pointer objects */
 #define SWIG_POINTER_OWN           0x1
@@ -295,10 +302,10 @@
 extern "C" {
 #endif
 
-typedef void *(*swig_converter_func)(void *);
+typedef void *(*swig_converter_func)(void *, int *);
 typedef struct swig_type_info *(*swig_dycast_func)(void **);
 
-/* Structure to store inforomation on one type */
+/* Structure to store information on one type */
 typedef struct swig_type_info {
   const char             *name;			/* mangled name of this type */
   const char             *str;			/* human readable name of this type */
@@ -343,7 +350,7 @@
     while ((*f2 == ' ') && (f2 != l2)) ++f2;
     if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
   }
-  return (l1 - f1) - (l2 - f2);
+  return (int)((l1 - f1) - (l2 - f2));
 }
 
 /*
@@ -425,8 +432,8 @@
   Cast a pointer up an inheritance hierarchy
 */
 SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
+SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
 }
 
 /* 
@@ -697,8 +704,6 @@
 
 
 
-/* Python.h has to appear first */
-#include <Python.h>
 
 /* Add PyOS_snprintf for old Pythons */
 #if PY_VERSION_HEX < 0x02020000
@@ -779,6 +784,14 @@
 }
 #endif
 
+/* Py_ssize_t for old Pythons */
+/* This code is as recommended by: */
+/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
+#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
+typedef int Py_ssize_t;
+# define PY_SSIZE_T_MAX INT_MAX
+# define PY_SSIZE_T_MIN INT_MIN
+#endif
 
 /* -----------------------------------------------------------------------------
  * error manipulation
@@ -844,7 +857,7 @@
     Py_DECREF(old_str);
     Py_DECREF(value);
   } else {
-    PyErr_Format(PyExc_RuntimeError, mesg);
+    PyErr_SetString(PyExc_RuntimeError, mesg);
   }
 }
 
@@ -1084,14 +1097,14 @@
 /* Unpack the argument tuple */
 
 SWIGINTERN int
-SWIG_Python_UnpackTuple(PyObject *args, const char *name, int min, int max, PyObject **objs)
+SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
 {
   if (!args) {
     if (!min && !max) {
       return 1;
     } else {
       PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
-		   name, (min == max ? "" : "at least "), min);
+		   name, (min == max ? "" : "at least "), (int)min);
       return 0;
     }
   }  
@@ -1099,14 +1112,14 @@
     PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
     return 0;
   } else {
-    register int l = PyTuple_GET_SIZE(args);
+    register Py_ssize_t l = PyTuple_GET_SIZE(args);
     if (l < min) {
       PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at least "), min, l);
+		   name, (min == max ? "" : "at least "), (int)min, (int)l);
       return 0;
     } else if (l > max) {
       PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at most "), max, l);
+		   name, (min == max ? "" : "at most "), (int)max, (int)l);
       return 0;
     } else {
       register int i;
@@ -1172,7 +1185,7 @@
 SWIGRUNTIMEINLINE PyObject * 
 _SWIG_Py_None(void)
 {
-  PyObject *none = Py_BuildValue("");
+  PyObject *none = Py_BuildValue((char*)"");
   Py_DECREF(none);
   return none;
 }
@@ -1404,7 +1417,7 @@
 {
   PySwigObject *sobj = (PySwigObject *) v;
   PyObject *next = sobj->next;
-  if (sobj->own) {
+  if (sobj->own == SWIG_POINTER_OWN) {
     swig_type_info *ty = sobj->ty;
     PySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;
     PyObject *destroy = data ? data->destroy : 0;
@@ -1422,12 +1435,13 @@
 	res = ((*meth)(mself, v));
       }
       Py_XDECREF(res);
-    } else {
-      const char *name = SWIG_TypePrettyName(ty);
+    } 
 #if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
-      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", name);
-#endif
+    else {
+      const char *name = SWIG_TypePrettyName(ty);
+      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
     }
+#endif
   } 
   Py_XDECREF(next);
   PyObject_DEL(v);
@@ -1585,9 +1599,11 @@
     (unaryfunc)0,                 /*nb_float*/
     (unaryfunc)PySwigObject_oct,  /*nb_oct*/
     (unaryfunc)PySwigObject_hex,  /*nb_hex*/
-#if PY_VERSION_HEX >= 0x02020000
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */ 
-#elif PY_VERSION_HEX >= 0x02000000
+#if PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
+#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
+#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
     0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
 #endif
   };
@@ -1930,7 +1946,7 @@
 
 SWIGRUNTIME int
 SWIG_Python_AcquirePtr(PyObject *obj, int own) {
-  if (own) {
+  if (own == SWIG_POINTER_OWN) {
     PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
     if (sobj) {
       int oldown = sobj->own;
@@ -1951,6 +1967,8 @@
     return SWIG_OK;
   } else {
     PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
+    if (own)
+      *own = 0;
     while (sobj) {
       void *vptr = sobj->ptr;
       if (ty) {
@@ -1964,7 +1982,15 @@
 	  if (!tc) {
 	    sobj = (PySwigObject *)sobj->next;
 	  } else {
-	    if (ptr) *ptr = SWIG_TypeCast(tc,vptr);
+	    if (ptr) {
+              int newmemory = 0;
+              *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
+              if (newmemory == SWIG_CAST_NEW_MEMORY) {
+                assert(own);
+                if (own)
+                  *own = *own | SWIG_CAST_NEW_MEMORY;
+              }
+            }
 	    break;
 	  }
 	}
@@ -1974,7 +2000,8 @@
       }
     }
     if (sobj) {
-      if (own) *own = sobj->own;
+      if (own)
+        *own = *own | sobj->own;
       if (flags & SWIG_POINTER_DISOWN) {
 	sobj->own = 0;
       }
@@ -2031,7 +2058,7 @@
     void *vptr = 0;
     
     /* here we get the method pointer for callbacks */
-    char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
+    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
     const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
     if (desc) {
       desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
@@ -2039,8 +2066,13 @@
     }
     if (ty) {
       swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
-      if (!tc) return SWIG_ERROR;
-      *ptr = SWIG_TypeCast(tc,vptr);
+      if (tc) {
+        int newmemory = 0;
+        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
+        assert(!newmemory); /* newmemory handling not yet implemented */
+      } else {
+        return SWIG_ERROR;
+      }
     } else {
       *ptr = vptr;
     }
@@ -2152,7 +2184,7 @@
    return;
  }
 #endif
- dict = PyObject_GetAttrString(inst, "__dict__");
+ dict = PyObject_GetAttrString(inst, (char*)"__dict__");
  PyDict_SetItem(dict, SWIG_This(), swig_this);
  Py_DECREF(dict);
 } 
@@ -2293,7 +2325,7 @@
 
 /* The python cached type query */
 SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache() {
+SWIG_Python_TypeCache(void) {
   static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
   return cache;
 }
@@ -2443,15 +2475,31 @@
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_SELboolean swig_types[0]
-#define SWIGTYPE_p_access_vector_t swig_types[1]
-#define SWIGTYPE_p_char swig_types[2]
-#define SWIGTYPE_p_int swig_types[3]
-#define SWIGTYPE_p_p_char swig_types[4]
-#define SWIGTYPE_p_p_p_char swig_types[5]
-#define SWIGTYPE_p_security_context_t swig_types[6]
-#define SWIGTYPE_p_unsigned_int swig_types[7]
-static swig_type_info *swig_types[9];
-static swig_module_info swig_module = {swig_types, 8, 0, 0, 0, 0};
+#define SWIGTYPE_p_av_decision swig_types[1]
+#define SWIGTYPE_p_avc_cache_stats swig_types[2]
+#define SWIGTYPE_p_avc_entry swig_types[3]
+#define SWIGTYPE_p_avc_entry_ref swig_types[4]
+#define SWIGTYPE_p_avc_lock_callback swig_types[5]
+#define SWIGTYPE_p_avc_log_callback swig_types[6]
+#define SWIGTYPE_p_avc_memory_callback swig_types[7]
+#define SWIGTYPE_p_avc_thread_callback swig_types[8]
+#define SWIGTYPE_p_char swig_types[9]
+#define SWIGTYPE_p_f_p_f_void__void__p_void swig_types[10]
+#define SWIGTYPE_p_f_p_q_const__char_v_______void swig_types[11]
+#define SWIGTYPE_p_f_p_void__void swig_types[12]
+#define SWIGTYPE_p_f_p_void_unsigned_short_p_char_size_t__void swig_types[13]
+#define SWIGTYPE_p_f_size_t__p_void swig_types[14]
+#define SWIGTYPE_p_f_void__p_void swig_types[15]
+#define SWIGTYPE_p_ino_t swig_types[16]
+#define SWIGTYPE_p_int swig_types[17]
+#define SWIGTYPE_p_p_char swig_types[18]
+#define SWIGTYPE_p_p_p_char swig_types[19]
+#define SWIGTYPE_p_p_security_id swig_types[20]
+#define SWIGTYPE_p_security_id swig_types[21]
+#define SWIGTYPE_p_unsigned_int swig_types[22]
+#define SWIGTYPE_p_unsigned_short swig_types[23]
+static swig_type_info *swig_types[25];
+static swig_module_info swig_module = {swig_types, 24, 0, 0, 0, 0};
 #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
 #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
 
@@ -2459,7 +2507,7 @@
 
 #if (PY_VERSION_HEX <= 0x02000000)
 # if !defined(SWIG_PYTHON_CLASSIC)
-#  error "This python version requires to use swig with the '-classic' option"
+#  error "This python version requires swig to be run with the '-classic' option"
 # endif
 #endif
 
@@ -2470,7 +2518,8 @@
 
 #define SWIG_name    "_selinux"
 
-#define SWIGVERSION 0x010329 
+#define SWIGVERSION 0x010335 
+#define SWIG_VERSION SWIGVERSION
 
 
 #define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
@@ -2480,6 +2529,13 @@
 	#include "selinux/selinux.h"
 
 
+	#include "selinux/selinux.h"
+	#include "../include/selinux/avc.h"
+	#include "../include/selinux/selinux.h"
+	#include "../include/selinux/get_default_type.h"
+	#include "../include/selinux/get_context_list.h"
+
+
   #define SWIG_From_long   PyInt_FromLong 
 
 
@@ -2490,15 +2546,81 @@
 }
 
 
-#include <limits.h>
-#ifndef LLONG_MIN
-# define LLONG_MIN	LONG_LONG_MIN
-#endif
-#ifndef LLONG_MAX
-# define LLONG_MAX	LONG_LONG_MAX
+SWIGINTERN swig_type_info*
+SWIG_pchar_descriptor(void)
+{
+  static int init = 0;
+  static swig_type_info* info = 0;
+  if (!init) {
+    info = SWIG_TypeQuery("_p_char");
+    init = 1;
+  }
+  return info;
+}
+
+
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
+{
+  if (PyString_Check(obj)) {
+    char *cstr; Py_ssize_t len;
+    PyString_AsStringAndSize(obj, &cstr, &len);
+    if (cptr)  {
+      if (alloc) {
+	/* 
+	   In python the user should not be able to modify the inner
+	   string representation. To warranty that, if you define
+	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
+	   buffer is always returned.
+
+	   The default behavior is just to return the pointer value,
+	   so, be careful.
+	*/ 
+#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
+	if (*alloc != SWIG_OLDOBJ) 
+#else
+	if (*alloc == SWIG_NEWOBJ) 
 #endif
-#ifndef ULLONG_MAX
-# define ULLONG_MAX	ULONG_LONG_MAX
+	  {
+	    *cptr = (char *)memcpy((char *)malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
+	    *alloc = SWIG_NEWOBJ;
+	  }
+	else {
+	  *cptr = cstr;
+	  *alloc = SWIG_OLDOBJ;
+	}
+      } else {
+	*cptr = PyString_AsString(obj);
+      }
+    }
+    if (psize) *psize = len + 1;
+    return SWIG_OK;
+  } else {
+    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+    if (pchar_descriptor) {
+      void* vptr = 0;
+      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
+	if (cptr) *cptr = (char *) vptr;
+	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
+	if (alloc) *alloc = SWIG_OLDOBJ;
+	return SWIG_OK;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+
+
+
+#include <limits.h>
+#if !defined(SWIG_NO_LLONG_MAX)
+# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
+#   define LLONG_MAX __LONG_LONG_MAX__
+#   define LLONG_MIN (-LLONG_MAX - 1LL)
+#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+# endif
 #endif
 
 
@@ -2583,13 +2705,18 @@
 
 
 SWIGINTERN int
-SWIG_AsVal_long (PyObject *obj, long* val)
+SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
 {
   if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
+    long v = PyInt_AsLong(obj);
+    if (v >= 0) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      return SWIG_OverflowError;
+    }
   } else if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
+    unsigned long v = PyLong_AsUnsignedLong(obj);
     if (!PyErr_Occurred()) {
       if (val) *val = v;
       return SWIG_OK;
@@ -2600,7 +2727,7 @@
 #ifdef SWIG_PYTHON_CAST_MODE
   {
     int dispatch = 0;
-    long v = PyInt_AsLong(obj);
+    unsigned long v = PyLong_AsUnsignedLong(obj);
     if (!PyErr_Occurred()) {
       if (val) *val = v;
       return SWIG_AddCast(SWIG_OK);
@@ -2610,8 +2737,8 @@
     if (!dispatch) {
       double d;
       int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
-	if (val) *val = (long)(d);
+      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
+	if (val) *val = (unsigned long)(d);
 	return res;
       }
     }
@@ -2622,102 +2749,29 @@
 
 
 SWIGINTERN int
-SWIG_AsVal_int (PyObject * obj, int *val)
+SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
 {
-  long v;
-  int res = SWIG_AsVal_long (obj, &v);
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
   if (SWIG_IsOK(res)) {
-    if ((v < INT_MIN || v > INT_MAX)) {
+    if ((v > UINT_MAX)) {
       return SWIG_OverflowError;
     } else {
-      if (val) *val = (int)(v);
+      if (val) *val = (unsigned int)(v);
     }
   }  
   return res;
 }
 
 
-SWIGINTERN swig_type_info*
-SWIG_pchar_descriptor()
-{
-  static int init = 0;
-  static swig_type_info* info = 0;
-  if (!init) {
-    info = SWIG_TypeQuery("_p_char");
-    init = 1;
-  }
-  return info;
-}
-
-
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-  if (PyString_Check(obj)) {
-    char *cstr; int len;
-    PyString_AsStringAndSize(obj, &cstr, &len);
-    if (cptr)  {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = (char *)memcpy((char *)malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-	*cptr = PyString_AsString(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-
-
-
 SWIGINTERN int
-SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
+SWIG_AsVal_long (PyObject *obj, long* val)
 {
   if (PyInt_Check(obj)) {
-    long v = PyInt_AsLong(obj);
-    if (v >= 0) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      return SWIG_OverflowError;
-    }
+    if (val) *val = PyInt_AsLong(obj);
+    return SWIG_OK;
   } else if (PyLong_Check(obj)) {
-    unsigned long v = PyLong_AsUnsignedLong(obj);
+    long v = PyLong_AsLong(obj);
     if (!PyErr_Occurred()) {
       if (val) *val = v;
       return SWIG_OK;
@@ -2728,7 +2782,7 @@
 #ifdef SWIG_PYTHON_CAST_MODE
   {
     int dispatch = 0;
-    unsigned long v = PyLong_AsUnsignedLong(obj);
+    long v = PyInt_AsLong(obj);
     if (!PyErr_Occurred()) {
       if (val) *val = v;
       return SWIG_AddCast(SWIG_OK);
@@ -2738,8 +2792,8 @@
     if (!dispatch) {
       double d;
       int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
-	if (val) *val = (unsigned long)(d);
+      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
+	if (val) *val = (long)(d);
 	return res;
       }
     }
@@ -2749,32 +2803,63 @@
 }
 
 
-SWIGINTERNINLINE int
-SWIG_AsVal_size_t (PyObject * obj, size_t *val)
+SWIGINTERN int
+SWIG_AsVal_int (PyObject * obj, int *val)
 {
-  unsigned long v;
-  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
-  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
+  long v;
+  int res = SWIG_AsVal_long (obj, &v);
+  if (SWIG_IsOK(res)) {
+    if ((v < INT_MIN || v > INT_MAX)) {
+      return SWIG_OverflowError;
+    } else {
+      if (val) *val = (int)(v);
+    }
+  }  
   return res;
 }
 
 
+SWIGINTERNINLINE PyObject* 
+SWIG_From_unsigned_SS_long  (unsigned long value)
+{
+  return (value > LONG_MAX) ?
+    PyLong_FromUnsignedLong(value) : PyInt_FromLong((long)(value)); 
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_unsigned_SS_int  (unsigned int value)
+{    
+  return SWIG_From_unsigned_SS_long  (value);
+}
+
+
 SWIGINTERN int
-SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
+SWIG_AsVal_unsigned_SS_short (PyObject * obj, unsigned short *val)
 {
   unsigned long v;
   int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
   if (SWIG_IsOK(res)) {
-    if ((v > UINT_MAX)) {
+    if ((v > USHRT_MAX)) {
       return SWIG_OverflowError;
     } else {
-      if (val) *val = (unsigned int)(v);
+      if (val) *val = (unsigned short)(v);
     }
   }  
   return res;
 }
 
 
+SWIGINTERNINLINE int
+SWIG_AsVal_size_t (PyObject * obj, size_t *val)
+{
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
+  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
+  return res;
+}
+
+
 SWIGINTERNINLINE PyObject *
 SWIG_FromCharPtrAndSize(const char* carray, size_t size)
 {
@@ -2798,6 +2883,13 @@
   return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
 }
 
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_unsigned_SS_short  (unsigned short value)
+{    
+  return SWIG_From_unsigned_SS_long  (value);
+}
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -2831,21 +2923,19 @@
   PyObject *resultobj = 0;
   security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  security_context_t temp1 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
+  arg1 = &temp1;
   if (!PyArg_ParseTuple(args,(char *)":getcon")) SWIG_fail;
   result = (int)getcon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -2853,52 +2943,106 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_setcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getcon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
+  
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getcon_raw")) SWIG_fail;
+  result = (int)getcon_raw(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_setcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
   
   if (!PyArg_ParseTuple(args,(char *)"O:setcon",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setcon" "', argument " "1"" of type '" "security_context_t""'");
   }
+  arg1 = (security_context_t)(buf1);
   result = (int)setcon(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_setcon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:setcon_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setcon_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)setcon_raw(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
 SWIGINTERN PyObject *_wrap_getpidcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int arg1 ;
+  pid_t arg1 ;
   security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
-  int val1 ;
+  unsigned int val1 ;
   int ecode1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
+  arg2 = &temp2;
   if (!PyArg_ParseTuple(args,(char *)"O:getpidcon",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpidcon" "', argument " "1"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpidcon" "', argument " "1"" of type '" "pid_t""'");
   } 
-  arg1 = (int)(val1);
+  arg1 = (pid_t)(val1);
   result = (int)getpidcon(arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -2906,25 +3050,32 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_getprevcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getpidcon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t *arg1 = (security_context_t *) 0 ;
+  pid_t arg1 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  unsigned int val1 ;
+  int ecode1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
-  if (!PyArg_ParseTuple(args,(char *)":getprevcon")) SWIG_fail;
-  result = (int)getprevcon(arg1);
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:getpidcon_raw",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpidcon_raw" "', argument " "1"" of type '" "pid_t""'");
+  } 
+  arg1 = (pid_t)(val1);
+  result = (int)getpidcon_raw(arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -2932,25 +3083,23 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_getexeccon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getprevcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  security_context_t temp1 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
-  if (!PyArg_ParseTuple(args,(char *)":getexeccon")) SWIG_fail;
-  result = (int)getexeccon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getprevcon")) SWIG_fail;
+  result = (int)getprevcon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -2958,43 +3107,47 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_setexeccon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getprevcon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:setexeccon",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
-  }
-  result = (int)setexeccon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getprevcon_raw")) SWIG_fail;
+  result = (int)getprevcon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_getfscreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getexeccon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  security_context_t temp1 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
-  if (!PyArg_ParseTuple(args,(char *)":getfscreatecon")) SWIG_fail;
-  result = (int)getfscreatecon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getexeccon")) SWIG_fail;
+  result = (int)getexeccon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -3002,87 +3155,97 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_setfscreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getexeccon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:setfscreatecon",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
-  }
-  result = (int)setfscreatecon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getexeccon_raw")) SWIG_fail;
+  result = (int)getexeccon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_getkeycreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setexeccon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t *arg1 = (security_context_t *) 0 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  {
-    arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)"O:setexeccon",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setexeccon" "', argument " "1"" of type '" "security_context_t""'");
   }
-  if (!PyArg_ParseTuple(args,(char *)":getkeycreatecon")) SWIG_fail;
-  result = (int)getkeycreatecon(arg1);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setexeccon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
-  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_setkeycreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setexeccon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:setkeycreatecon",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
+  if (!PyArg_ParseTuple(args,(char *)"O:setexeccon_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setexeccon_raw" "', argument " "1"" of type '" "security_context_t""'");
   }
-  result = (int)setkeycreatecon(arg1);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setexeccon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_getsockcreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getfscreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp1 ;
-  char *temp10 ;
+  security_context_t temp1 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
-  if (!PyArg_ParseTuple(args,(char *)":getsockcreatecon")) SWIG_fail;
-  result = (int)getsockcreatecon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getfscreatecon")) SWIG_fail;
+  result = (int)getfscreatecon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg1)
-    temp10 = *arg1;
-    else
-    temp10 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp10));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -3090,54 +3253,47 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_setsockcreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getfscreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:setsockcreatecon",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
-  }
-  result = (int)setsockcreatecon(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getfscreatecon_raw")) SWIG_fail;
+  result = (int)getfscreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_getfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setfscreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:getfilecon",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"O:setfscreatecon",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getfilecon" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setfscreatecon" "', argument " "1"" of type '" "security_context_t""'");
   }
-  arg1 = buf1;
-  result = (int)getfilecon((char const *)arg1,arg2);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setfscreatecon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
-  }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
@@ -3146,36 +3302,23 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_lgetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setfscreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:lgetfilecon",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"O:setfscreatecon_raw",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lgetfilecon" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setfscreatecon_raw" "', argument " "1"" of type '" "security_context_t""'");
   }
-  arg1 = buf1;
-  result = (int)lgetfilecon((char const *)arg1,arg2);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setfscreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
-  }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
@@ -3184,34 +3327,47 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_fgetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getkeycreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int arg1 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  int val1 ;
-  int ecode1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  {
-    arg2 = &temp2;
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getkeycreatecon")) SWIG_fail;
+  result = (int)getkeycreatecon(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
   }
-  if (!PyArg_ParseTuple(args,(char *)"O:fgetfilecon",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fgetfilecon" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  result = (int)fgetfilecon(arg1,arg2);
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_getkeycreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t *arg1 = (security_context_t *) 0 ;
+  int result;
+  security_context_t temp1 = 0 ;
+  
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getkeycreatecon_raw")) SWIG_fail;
+  result = (int)getkeycreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -3219,27 +3375,22 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_setfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setkeycreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  security_context_t arg2 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OO:setfilecon",&obj0,&obj1)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"O:setkeycreatecon",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setfilecon" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = buf1;
-  {
-    arg2 = (security_context_t)PyString_AsString(obj1);
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setkeycreatecon" "', argument " "1"" of type '" "security_context_t""'");
   }
-  result = (int)setfilecon((char const *)arg1,arg2);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setkeycreatecon(arg1);
   resultobj = SWIG_From_int((int)(result));
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
@@ -3249,27 +3400,22 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_lsetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setkeycreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  security_context_t arg2 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OO:lsetfilecon",&obj0,&obj1)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"O:setkeycreatecon_raw",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lsetfilecon" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setkeycreatecon_raw" "', argument " "1"" of type '" "security_context_t""'");
   }
-  arg1 = buf1;
-  {
-    arg2 = (security_context_t)PyString_AsString(obj1);
-  }
-  result = (int)lsetfilecon((char const *)arg1,arg2);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setkeycreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
@@ -3279,61 +3425,23 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_fsetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getsockcreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int arg1 ;
-  security_context_t arg2 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OO:fsetfilecon",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fsetfilecon" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  {
-    arg2 = (security_context_t)PyString_AsString(obj1);
-  }
-  result = (int)fsetfilecon(arg1,arg2);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getsockcreatecon")) SWIG_fail;
+  result = (int)getsockcreatecon(arg1);
   resultobj = SWIG_From_int((int)(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_getpeercon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
-  int result;
-  int val1 ;
-  int ecode1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
-  PyObject * obj0 = 0 ;
-  
-  {
-    arg2 = &temp2;
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
   }
-  if (!PyArg_ParseTuple(args,(char *)"O:getpeercon",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpeercon" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  result = (int)getpeercon(arg1,arg2);
-  resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -3341,108 +3449,108 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_mkload_policy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getsockcreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int arg1 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
   int result;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
+  security_context_t temp1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:selinux_mkload_policy",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "selinux_mkload_policy" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  result = (int)selinux_mkload_policy(arg1);
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":getsockcreatecon_raw")) SWIG_fail;
+  result = (int)getsockcreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_init_load_policy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setsockcreatecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int *arg1 = (int *) 0 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
-  int temp1 ;
-  int res1 = SWIG_TMPOBJ ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  arg1 = &temp1;
-  if (!PyArg_ParseTuple(args,(char *)":selinux_init_load_policy")) SWIG_fail;
-  result = (int)selinux_init_load_policy(arg1);
-  resultobj = SWIG_From_int((int)(result));
-  if (SWIG_IsTmpObj(res1)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg1)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags));
+  if (!PyArg_ParseTuple(args,(char *)"O:setsockcreatecon",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setsockcreatecon" "', argument " "1"" of type '" "security_context_t""'");
   }
+  arg1 = (security_context_t)(buf1);
+  result = (int)setsockcreatecon(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_set_boolean_list(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setsockcreatecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  size_t arg1 ;
-  SELboolean *arg2 = (SELboolean *) 0 ;
-  int arg3 ;
+  security_context_t arg1 = (security_context_t) 0 ;
   int result;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OOO:security_set_boolean_list",&obj0,&obj1,&obj2)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "security_set_boolean_list" "', argument " "1"" of type '" "size_t""'");
-  } 
-  arg1 = (size_t)(val1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SELboolean, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_set_boolean_list" "', argument " "2"" of type '" "SELboolean *""'"); 
+  if (!PyArg_ParseTuple(args,(char *)"O:setsockcreatecon_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setsockcreatecon_raw" "', argument " "1"" of type '" "security_context_t""'");
   }
-  arg2 = (SELboolean *)(argp2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_set_boolean_list" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
-  result = (int)security_set_boolean_list(arg1,arg2,arg3);
+  arg1 = (security_context_t)(buf1);
+  result = (int)setsockcreatecon_raw(arg1);
   resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_load_booleans(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:security_load_booleans",&obj0)) SWIG_fail;
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:getfilecon",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_load_booleans" "', argument " "1"" of type '" "char *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getfilecon" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)security_load_booleans(arg1);
+  arg1 = (char *)(buf1);
+  result = (int)getfilecon((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
@@ -3451,246 +3559,4216 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_security_check_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_getfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  char *arg1 = (char *) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:security_check_context",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:getfilecon_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getfilecon_raw" "', argument " "1"" of type '" "char const *""'");
   }
-  result = (int)security_check_context(arg1);
+  arg1 = (char *)(buf1);
+  result = (int)getfilecon_raw((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_canonicalize_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_lgetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  char *arg1 = (char *) 0 ;
   security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
-  security_context_t temp2 ;
-  char *temp20 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:security_canonicalize_context",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:lgetfilecon",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lgetfilecon" "', argument " "1"" of type '" "char const *""'");
   }
-  result = (int)security_canonicalize_context(arg1,arg2);
+  arg1 = (char *)(buf1);
+  result = (int)lgetfilecon((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_getenforce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_lgetfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":security_getenforce")) SWIG_fail;
-  result = (int)security_getenforce();
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:lgetfilecon_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lgetfilecon_raw" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)lgetfilecon_raw((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_setenforce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_fgetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
   int val1 ;
   int ecode1 = 0 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:security_setenforce",&obj0)) SWIG_fail;
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:fgetfilecon",&obj0)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "security_setenforce" "', argument " "1"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fgetfilecon" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = (int)(val1);
-  result = (int)security_setenforce(arg1);
+  result = (int)fgetfilecon(arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_policyvers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_fgetfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
+  int arg1 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":security_policyvers")) SWIG_fail;
-  result = (int)security_policyvers();
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:fgetfilecon_raw",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fgetfilecon_raw" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  result = (int)fgetfilecon_raw(arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_get_boolean_names(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char ***arg1 = (char ***) 0 ;
-  int *arg2 = (int *) 0 ;
+  char *arg1 = (char *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
   int result;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int temp2 ;
-  int res2 = SWIG_TMPOBJ ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  arg2 = &temp2;
-  if (!PyArg_ParseTuple(args,(char *)"O:security_get_boolean_names",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_p_p_char, 0 |  0 );
+  if (!PyArg_ParseTuple(args,(char *)"OO:setfilecon",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_get_boolean_names" "', argument " "1"" of type '" "char ***""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setfilecon" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = (char ***)(argp1);
-  result = (int)security_get_boolean_names(arg1,arg2);
-  resultobj = SWIG_From_int((int)(result));
-  if (SWIG_IsTmpObj(res2)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "setfilecon" "', argument " "2"" of type '" "security_context_t""'");
   }
+  arg2 = (security_context_t)(buf2);
+  result = (int)setfilecon((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_get_boolean_pending(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_setfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:security_get_boolean_pending",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OO:setfilecon_raw",&obj0,&obj1)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_get_boolean_pending" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "setfilecon_raw" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)security_get_boolean_pending((char const *)arg1);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "setfilecon_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)setfilecon_raw((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return resultobj;
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_get_boolean_active(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_lsetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:security_get_boolean_active",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OO:lsetfilecon",&obj0,&obj1)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_get_boolean_active" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lsetfilecon" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)security_get_boolean_active((char const *)arg1);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lsetfilecon" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)lsetfilecon((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return resultobj;
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_set_boolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_lsetfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
-  int arg2 ;
+  security_context_t arg2 = (security_context_t) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OO:security_set_boolean",&obj0,&obj1)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OO:lsetfilecon_raw",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lsetfilecon_raw" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lsetfilecon_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)lsetfilecon_raw((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_fsetfilecon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:fsetfilecon",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fsetfilecon" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fsetfilecon" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)fsetfilecon(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_fsetfilecon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:fsetfilecon_raw",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fsetfilecon_raw" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fsetfilecon_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)fsetfilecon_raw(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_getpeercon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:getpeercon",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpeercon" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  result = (int)getpeercon(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_getpeercon_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:getpeercon_raw",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getpeercon_raw" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  result = (int)getpeercon_raw(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_allowed_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:av_decision_allowed_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_allowed_set" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "av_decision_allowed_set" "', argument " "2"" of type '" "access_vector_t""'");
+  } 
+  arg2 = (access_vector_t)(val2);
+  if (arg1) (arg1)->allowed = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_allowed_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:av_decision_allowed_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_allowed_get" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  result = (access_vector_t) ((arg1)->allowed);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_decided_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:av_decision_decided_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_decided_set" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "av_decision_decided_set" "', argument " "2"" of type '" "access_vector_t""'");
+  } 
+  arg2 = (access_vector_t)(val2);
+  if (arg1) (arg1)->decided = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_decided_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:av_decision_decided_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_decided_get" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  result = (access_vector_t) ((arg1)->decided);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_auditallow_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:av_decision_auditallow_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_auditallow_set" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "av_decision_auditallow_set" "', argument " "2"" of type '" "access_vector_t""'");
+  } 
+  arg2 = (access_vector_t)(val2);
+  if (arg1) (arg1)->auditallow = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_auditallow_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:av_decision_auditallow_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_auditallow_get" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  result = (access_vector_t) ((arg1)->auditallow);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_auditdeny_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:av_decision_auditdeny_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_auditdeny_set" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "av_decision_auditdeny_set" "', argument " "2"" of type '" "access_vector_t""'");
+  } 
+  arg2 = (access_vector_t)(val2);
+  if (arg1) (arg1)->auditdeny = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_auditdeny_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  access_vector_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:av_decision_auditdeny_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_auditdeny_get" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  result = (access_vector_t) ((arg1)->auditdeny);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_seqno_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:av_decision_seqno_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_seqno_set" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "av_decision_seqno_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->seqno = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_av_decision_seqno_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:av_decision_seqno_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "av_decision_seqno_get" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  result = (unsigned int) ((arg1)->seqno);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_av_decision(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_av_decision")) SWIG_fail;
+  result = (struct av_decision *)calloc(1, sizeof(struct av_decision));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_av_decision, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_av_decision(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct av_decision *arg1 = (struct av_decision *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_av_decision",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_av_decision, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_av_decision" "', argument " "1"" of type '" "struct av_decision *""'"); 
+  }
+  arg1 = (struct av_decision *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *av_decision_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_av_decision, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_security_compute_av(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  access_vector_t arg4 ;
+  struct av_decision *arg5 = (struct av_decision *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  unsigned int val4 ;
+  int ecode4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:security_compute_av",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_av" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_av" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_av" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "security_compute_av" "', argument " "4"" of type '" "access_vector_t""'");
+  } 
+  arg4 = (access_vector_t)(val4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "security_compute_av" "', argument " "5"" of type '" "struct av_decision *""'"); 
+  }
+  arg5 = (struct av_decision *)(argp5);
+  result = (int)security_compute_av(arg1,arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_av_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  access_vector_t arg4 ;
+  struct av_decision *arg5 = (struct av_decision *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  unsigned int val4 ;
+  int ecode4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:security_compute_av_raw",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_av_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_av_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_av_raw" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "security_compute_av_raw" "', argument " "4"" of type '" "access_vector_t""'");
+  } 
+  arg4 = (access_vector_t)(val4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "security_compute_av_raw" "', argument " "5"" of type '" "struct av_decision *""'"); 
+  }
+  arg5 = (struct av_decision *)(argp5);
+  result = (int)security_compute_av_raw(arg1,arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_create(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_create",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_create" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_create" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_create" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_create(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_create_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_create_raw",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_create_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_create_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_create_raw" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_create_raw(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_relabel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_relabel",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_relabel" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_relabel" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_relabel" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_relabel(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_relabel_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_relabel_raw",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_relabel_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_relabel_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_relabel_raw" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_relabel_raw(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_member(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_member",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_member" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_member" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_member" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_member(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_member_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_class_t arg3 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  security_context_t temp4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_compute_member_raw",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_member_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_member_raw" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_compute_member_raw" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  result = (int)security_compute_member_raw(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_user(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  char *arg2 = (char *) 0 ;
+  security_context_t **arg3 = (security_context_t **) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  security_context_t *temp3 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  {
+    arg3 = &temp3;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_compute_user",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_user" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_user" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  result = (int)security_compute_user(arg1,(char const *)arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    PyObject* plist;
+    int i, len = 0;
+    
+    if (*arg3) {
+      while((*arg3)[len])
+      len++;
+      plist = PyList_New(len);
+      for (i = 0; i < len; i++) {
+        PyList_SetItem(plist, i, PyString_FromString((*arg3)[i]));
+      }
+    } else {
+      plist = PyList_New(0);
+    }
+    
+    resultobj = SWIG_Python_AppendOutput(resultobj, plist);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
+  }
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_compute_user_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  char *arg2 = (char *) 0 ;
+  security_context_t **arg3 = (security_context_t **) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  security_context_t *temp3 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  {
+    arg3 = &temp3;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_compute_user_raw",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_compute_user_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_compute_user_raw" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  result = (int)security_compute_user_raw(arg1,(char const *)arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    PyObject* plist;
+    int i, len = 0;
+    
+    if (*arg3) {
+      while((*arg3)[len])
+      len++;
+      plist = PyList_New(len);
+      for (i = 0; i < len; i++) {
+        PyList_SetItem(plist, i, PyString_FromString((*arg3)[i]));
+      }
+    } else {
+      plist = PyList_New(0);
+    }
+    
+    resultobj = SWIG_Python_AppendOutput(resultobj, plist);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
+  }
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_load_policy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  void *arg1 = (void *) 0 ;
+  size_t arg2 ;
+  int result;
+  int res1 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_load_policy",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_load_policy" "', argument " "1"" of type '" "void *""'"); 
+  }
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "security_load_policy" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = (size_t)(val2);
+  result = (int)security_load_policy(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_mkload_policy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_mkload_policy",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "selinux_mkload_policy" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  result = (int)selinux_mkload_policy(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_init_load_policy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int *arg1 = (int *) 0 ;
+  int result;
+  int temp1 ;
+  int res1 = SWIG_TMPOBJ ;
+  
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":selinux_init_load_policy")) SWIG_fail;
+  result = (int)selinux_init_load_policy(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (SWIG_IsTmpObj(res1)) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg1)));
+  } else {
+    int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags));
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SELboolean_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *arg1 = (SELboolean *) 0 ;
+  char *arg2 = (char *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SELboolean_name_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SELboolean, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SELboolean_name_set" "', argument " "1"" of type '" "SELboolean *""'"); 
+  }
+  arg1 = (SELboolean *)(argp1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SELboolean_name_set" "', argument " "2"" of type '" "char *""'");
+  }
+  arg2 = (char *)(buf2);
+  if (arg1->name) free((char*)arg1->name);
+  if (arg2) {
+    size_t size = strlen((const char *)(arg2)) + 1;
+    arg1->name = (char *)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+  } else {
+    arg1->name = 0;
+  }
+  resultobj = SWIG_Py_Void();
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SELboolean_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *arg1 = (SELboolean *) 0 ;
+  char *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SELboolean_name_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SELboolean, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SELboolean_name_get" "', argument " "1"" of type '" "SELboolean *""'"); 
+  }
+  arg1 = (SELboolean *)(argp1);
+  result = (char *) ((arg1)->name);
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SELboolean_value_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *arg1 = (SELboolean *) 0 ;
+  int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SELboolean_value_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SELboolean, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SELboolean_value_set" "', argument " "1"" of type '" "SELboolean *""'"); 
+  }
+  arg1 = (SELboolean *)(argp1);
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SELboolean_value_set" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = (int)(val2);
+  if (arg1) (arg1)->value = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SELboolean_value_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *arg1 = (SELboolean *) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SELboolean_value_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SELboolean, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SELboolean_value_get" "', argument " "1"" of type '" "SELboolean *""'"); 
+  }
+  arg1 = (SELboolean *)(argp1);
+  result = (int) ((arg1)->value);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_SELboolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_SELboolean")) SWIG_fail;
+  result = (SELboolean *)calloc(1, sizeof(SELboolean));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SELboolean, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_SELboolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SELboolean *arg1 = (SELboolean *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_SELboolean",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SELboolean, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SELboolean" "', argument " "1"" of type '" "SELboolean *""'"); 
+  }
+  arg1 = (SELboolean *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *SELboolean_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_SELboolean, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_security_set_boolean_list(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  size_t arg1 ;
+  SELboolean *arg2 = (SELboolean *) 0 ;
+  int arg3 ;
+  int result;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:security_set_boolean_list",&obj0,&obj1,&obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "security_set_boolean_list" "', argument " "1"" of type '" "size_t""'");
+  } 
+  arg1 = (size_t)(val1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SELboolean, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_set_boolean_list" "', argument " "2"" of type '" "SELboolean *""'"); 
+  }
+  arg2 = (SELboolean *)(argp2);
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "security_set_boolean_list" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = (int)(val3);
+  result = (int)security_set_boolean_list(arg1,arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_load_booleans(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_load_booleans",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_load_booleans" "', argument " "1"" of type '" "char *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)security_load_booleans(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_check_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_check_context",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_check_context" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)security_check_context(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_check_context_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_check_context_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_check_context_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)security_check_context_raw(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_canonicalize_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:security_canonicalize_context",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_canonicalize_context" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)security_canonicalize_context(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_canonicalize_context_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:security_canonicalize_context_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_canonicalize_context_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)security_canonicalize_context_raw(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_getenforce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":security_getenforce")) SWIG_fail;
+  result = (int)security_getenforce();
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_setenforce(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int arg1 ;
+  int result;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_setenforce",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "security_setenforce" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
+  result = (int)security_setenforce(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_disable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":security_disable")) SWIG_fail;
+  result = (int)security_disable();
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_policyvers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":security_policyvers")) SWIG_fail;
+  result = (int)security_policyvers();
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_get_boolean_names(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char ***arg1 = (char ***) 0 ;
+  int *arg2 = (int *) 0 ;
+  int result;
+  char **temp11 ;
+  int temp21 ;
+  
+  {
+    arg1 = &temp11;
+    arg2 = &temp21;
+  }
+  if (!PyArg_ParseTuple(args,(char *)":security_get_boolean_names")) SWIG_fail;
+  result = (int)security_get_boolean_names(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    PyObject* list = PyList_New(*arg2);
+    int i;
+    for (i = 0; i < *arg2; i++) {
+      PyList_SetItem(list, i, PyString_FromString((*arg1)[i]));
+    }
+    resultobj = SWIG_Python_AppendOutput(resultobj, list);
+  }
+  {
+    int i;
+    if (*arg1) {
+      for (i = 0; i < *arg2; i++) {
+        free((*arg1)[i]);
+      }
+      free(*arg1);
+    }
+  }
+  return resultobj;
+fail:
+  {
+    int i;
+    if (*arg1) {
+      for (i = 0; i < *arg2; i++) {
+        free((*arg1)[i]);
+      }
+      free(*arg1);
+    }
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_get_boolean_pending(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_get_boolean_pending",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_get_boolean_pending" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)security_get_boolean_pending((char const *)arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_get_boolean_active(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_get_boolean_active",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_get_boolean_active" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)security_get_boolean_active((char const *)arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_set_boolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int arg2 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_set_boolean",&obj0,&obj1)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_set_boolean" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "security_set_boolean" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = (int)(val2);
-  result = (int)security_set_boolean((char const *)arg1,arg2);
-  resultobj = SWIG_From_int((int)(result));
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "security_set_boolean" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = (int)(val2);
+  result = (int)security_set_boolean((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_commit_booleans(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":security_commit_booleans")) SWIG_fail;
+  result = (int)security_commit_booleans();
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_string_to_security_class(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  security_class_t result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:string_to_security_class",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_to_security_class" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (security_class_t)string_to_security_class((char const *)arg1);
+  resultobj = SWIG_From_unsigned_SS_short((unsigned short)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_string_to_av_perm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_class_t arg1 ;
+  char *arg2 = (char *) 0 ;
+  access_vector_t result;
+  unsigned short val1 ;
+  int ecode1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:string_to_av_perm",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_short(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "string_to_av_perm" "', argument " "1"" of type '" "security_class_t""'");
+  } 
+  arg1 = (security_class_t)(val1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_to_av_perm" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  result = (access_vector_t)string_to_av_perm(arg1,(char const *)arg2);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_print_access_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_class_t arg1 ;
+  access_vector_t arg2 ;
+  unsigned short val1 ;
+  int ecode1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:print_access_vector",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_short(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "print_access_vector" "', argument " "1"" of type '" "security_class_t""'");
+  } 
+  arg1 = (security_class_t)(val1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "print_access_vector" "', argument " "2"" of type '" "access_vector_t""'");
+  } 
+  arg2 = (access_vector_t)(val2);
+  print_access_vector(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_set_matchpathcon_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  unsigned int arg1 ;
+  unsigned int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:set_matchpathcon_flags",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_matchpathcon_flags" "', argument " "1"" of type '" "unsigned int""'");
+  } 
+  arg1 = (unsigned int)(val1);
+  set_matchpathcon_flags(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:matchpathcon_init",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_init" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)matchpathcon_init((char const *)arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_init_prefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  char *arg2 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:matchpathcon_init_prefix",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_init_prefix" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "matchpathcon_init_prefix" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  result = (int)matchpathcon_init_prefix((char const *)arg1,(char const *)arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_fini(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":matchpathcon_fini")) SWIG_fail;
+  matchpathcon_fini();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  mode_t arg2 ;
+  security_context_t *arg3 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  security_context_t temp3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  arg3 = &temp3;
+  if (!PyArg_ParseTuple(args,(char *)"OO:matchpathcon",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "matchpathcon" "', argument " "2"" of type '" "mode_t""'");
+  } 
+  arg2 = (mode_t)(val2);
+  result = (int)matchpathcon((char const *)arg1,arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg3) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg3));
+    freecon(*arg3);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_index(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  mode_t arg2 ;
+  security_context_t *arg3 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  security_context_t temp3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  arg3 = &temp3;
+  if (!PyArg_ParseTuple(args,(char *)"OO:matchpathcon_index",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_index" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "matchpathcon_index" "', argument " "2"" of type '" "mode_t""'");
+  } 
+  arg2 = (mode_t)(val2);
+  result = (int)matchpathcon_index((char const *)arg1,arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg3) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg3));
+    freecon(*arg3);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_filespec_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  ino_t arg1 ;
+  int arg2 ;
+  char *arg3 = (char *) 0 ;
+  int result;
+  void *argp1 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:matchpathcon_filespec_add",&obj0,&obj1,&obj2)) SWIG_fail;
+  {
+    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ino_t,  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_filespec_add" "', argument " "1"" of type '" "ino_t""'"); 
+    }  
+    if (!argp1) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "matchpathcon_filespec_add" "', argument " "1"" of type '" "ino_t""'");
+    } else {
+      arg1 = *((ino_t *)(argp1));
+    }
+  }
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "matchpathcon_filespec_add" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = (int)(val2);
+  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "matchpathcon_filespec_add" "', argument " "3"" of type '" "char const *""'");
+  }
+  arg3 = (char *)(buf3);
+  result = (int)matchpathcon_filespec_add(arg1,arg2,(char const *)arg3);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  return resultobj;
+fail:
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_filespec_destroy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":matchpathcon_filespec_destroy")) SWIG_fail;
+  matchpathcon_filespec_destroy();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_filespec_eval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":matchpathcon_filespec_eval")) SWIG_fail;
+  matchpathcon_filespec_eval();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchpathcon_checkmatches(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:matchpathcon_checkmatches",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_checkmatches" "', argument " "1"" of type '" "char *""'");
+  }
+  arg1 = (char *)(buf1);
+  matchpathcon_checkmatches(arg1);
+  resultobj = SWIG_Py_Void();
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_matchmediacon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:matchmediacon",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchmediacon" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)matchmediacon((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_getenforcemode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int *arg1 = (int *) 0 ;
+  int result;
+  int temp1 ;
+  int res1 = SWIG_TMPOBJ ;
+  
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":selinux_getenforcemode")) SWIG_fail;
+  result = (int)selinux_getenforcemode(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (SWIG_IsTmpObj(res1)) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg1)));
+  } else {
+    int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags));
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_getpolicytype(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char **arg1 = (char **) 0 ;
+  int result;
+  char *temp1 = 0 ;
+  
+  arg1 = &temp1;
+  if (!PyArg_ParseTuple(args,(char *)":selinux_getpolicytype")) SWIG_fail;
+  result = (int)selinux_getpolicytype(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    free(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_policy_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_policy_root")) SWIG_fail;
+  result = (char *)selinux_policy_root();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_binary_policy_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_binary_policy_path")) SWIG_fail;
+  result = (char *)selinux_binary_policy_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_failsafe_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_failsafe_context_path")) SWIG_fail;
+  result = (char *)selinux_failsafe_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_removable_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_removable_context_path")) SWIG_fail;
+  result = (char *)selinux_removable_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_default_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_default_context_path")) SWIG_fail;
+  result = (char *)selinux_default_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_user_contexts_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_user_contexts_path")) SWIG_fail;
+  result = (char *)selinux_user_contexts_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_file_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_path")) SWIG_fail;
+  result = (char *)selinux_file_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_file_context_homedir_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_homedir_path")) SWIG_fail;
+  result = (char *)selinux_file_context_homedir_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_file_context_local_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_local_path")) SWIG_fail;
+  result = (char *)selinux_file_context_local_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_homedir_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_homedir_context_path")) SWIG_fail;
+  result = (char *)selinux_homedir_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_media_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_media_context_path")) SWIG_fail;
+  result = (char *)selinux_media_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_contexts_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_contexts_path")) SWIG_fail;
+  result = (char *)selinux_contexts_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_securetty_types_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_securetty_types_path")) SWIG_fail;
+  result = (char *)selinux_securetty_types_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_booleans_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_booleans_path")) SWIG_fail;
+  result = (char *)selinux_booleans_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_customizable_types_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_customizable_types_path")) SWIG_fail;
+  result = (char *)selinux_customizable_types_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_users_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_users_path")) SWIG_fail;
+  result = (char *)selinux_users_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_usersconf_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_usersconf_path")) SWIG_fail;
+  result = (char *)selinux_usersconf_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_translations_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_translations_path")) SWIG_fail;
+  result = (char *)selinux_translations_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_netfilter_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_netfilter_context_path")) SWIG_fail;
+  result = (char *)selinux_netfilter_context_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":selinux_path")) SWIG_fail;
+  result = (char *)selinux_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_check_passwd_access(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  access_vector_t arg1 ;
+  int result;
+  unsigned int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_check_passwd_access",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "selinux_check_passwd_access" "', argument " "1"" of type '" "access_vector_t""'");
+  } 
+  arg1 = (access_vector_t)(val1);
+  result = (int)selinux_check_passwd_access(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_checkPasswdAccess(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  access_vector_t arg1 ;
+  int result;
+  unsigned int val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:checkPasswdAccess",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "checkPasswdAccess" "', argument " "1"" of type '" "access_vector_t""'");
+  } 
+  arg1 = (access_vector_t)(val1);
+  result = (int)checkPasswdAccess(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_check_securetty_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_check_securetty_context",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_check_securetty_context" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)selinux_check_securetty_context(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_set_selinuxmnt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:set_selinuxmnt",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_selinuxmnt" "', argument " "1"" of type '" "char *""'");
+  }
+  arg1 = (char *)(buf1);
+  set_selinuxmnt(arg1);
+  resultobj = SWIG_Py_Void();
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_rpm_execcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  unsigned int arg1 ;
+  char *arg2 = (char *) 0 ;
+  char **arg3 ;
+  char **arg4 ;
+  int result;
+  unsigned int val1 ;
+  int ecode1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:rpm_execcon",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "rpm_execcon" "', argument " "1"" of type '" "unsigned int""'");
+  } 
+  arg1 = (unsigned int)(val1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "rpm_execcon" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  {
+    int i, size;
+    PyObject * s;
+    
+    if (!PySequence_Check(obj2)) {
+      PyErr_SetString(PyExc_ValueError, "Expected a sequence");
+      return NULL;
+    }
+    
+    size = PySequence_Size(obj2);
+    
+    arg3 = (char**) malloc(size + 1);
+    
+    for(i = 0; i < size; i++) {
+      if (!PyString_Check(PySequence_GetItem(obj2, i))) {
+        PyErr_SetString(PyExc_ValueError, "Sequence must contain only strings");
+        return NULL;
+      }
+    }
+    
+    for(i = 0; i < size; i++) {
+      s = PySequence_GetItem(obj2, i);
+      arg3[i] = (char*) malloc(PyString_Size(s) + 1);
+      strcpy(arg3[i], PyString_AsString(s));
+    }
+    arg3[size] = NULL;
+  }
+  {
+    int i, size;
+    PyObject * s;
+    
+    if (!PySequence_Check(obj3)) {
+      PyErr_SetString(PyExc_ValueError, "Expected a sequence");
+      return NULL;
+    }
+    
+    size = PySequence_Size(obj3);
+    
+    arg4 = (char**) malloc(size + 1);
+    
+    for(i = 0; i < size; i++) {
+      if (!PyString_Check(PySequence_GetItem(obj3, i))) {
+        PyErr_SetString(PyExc_ValueError, "Sequence must contain only strings");
+        return NULL;
+      }
+    }
+    
+    for(i = 0; i < size; i++) {
+      s = PySequence_GetItem(obj3, i);
+      arg4[i] = (char*) malloc(PyString_Size(s) + 1);
+      strcpy(arg4[i], PyString_AsString(s));
+    }
+    arg4[size] = NULL;
+  }
+  result = (int)rpm_execcon(arg1,(char const *)arg2,(char *const (*))arg3,(char *const (*))arg4);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    int i = 0;
+    while(arg3[i]) {
+      free(arg3[i]);
+      i++;
+    }
+    free(arg3);
+  }
+  {
+    int i = 0;
+    while(arg4[i]) {
+      free(arg4[i]);
+      i++;
+    }
+    free(arg4);
+  }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    int i = 0;
+    while(arg3[i]) {
+      free(arg3[i]);
+      i++;
+    }
+    free(arg3);
+  }
+  {
+    int i = 0;
+    while(arg4[i]) {
+      free(arg4[i]);
+      i++;
+    }
+    free(arg4);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_is_context_customizable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:is_context_customizable",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_context_customizable" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)is_context_customizable(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_trans_to_raw_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_trans_to_raw_context",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_trans_to_raw_context" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)selinux_trans_to_raw_context(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_raw_to_trans_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_raw_to_trans_context",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_raw_to_trans_context" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)selinux_raw_to_trans_context(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_getseuserbyname(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  char **arg2 = (char **) 0 ;
+  char **arg3 = (char **) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  char *temp2 = 0 ;
+  char *temp3 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  arg3 = &temp3;
+  if (!PyArg_ParseTuple(args,(char *)"O:getseuserbyname",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getseuserbyname" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)getseuserbyname((char const *)arg1,arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    free(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (*arg3) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg3));
+    free(*arg3);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_file_context_cmp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) (security_context_t)0 ;
+  security_context_t arg2 = (security_context_t) (security_context_t)0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:selinux_file_context_cmp",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_file_context_cmp" "', argument " "1"" of type '" "security_context_t const""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "selinux_file_context_cmp" "', argument " "2"" of type '" "security_context_t const""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)selinux_file_context_cmp(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_file_context_verify(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  mode_t arg2 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:selinux_file_context_verify",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_file_context_verify" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "selinux_file_context_verify" "', argument " "2"" of type '" "mode_t""'");
+  } 
+  arg2 = (mode_t)(val2);
+  result = (int)selinux_file_context_verify((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_selinux_lsetfilecon_default(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:selinux_lsetfilecon_default",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_lsetfilecon_default" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)selinux_lsetfilecon_default((char const *)arg1);
+  resultobj = SWIG_From_int((int)(result));
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_id_ctx_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *arg1 = (struct security_id *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_id_ctx_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_id_ctx_set" "', argument " "1"" of type '" "struct security_id *""'"); 
+  }
+  arg1 = (struct security_id *)(argp1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "security_id_ctx_set" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  if (arg1->ctx) free((char*)arg1->ctx);
+  if (arg2) {
+    size_t size = strlen((const char *)(arg2)) + 1;
+    arg1->ctx = (security_context_t)(char *)memcpy((char *)malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
+  } else {
+    arg1->ctx = 0;
+  }
+  resultobj = SWIG_Py_Void();
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_id_ctx_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *arg1 = (struct security_id *) 0 ;
+  security_context_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_id_ctx_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_id_ctx_get" "', argument " "1"" of type '" "struct security_id *""'"); 
+  }
+  arg1 = (struct security_id *)(argp1);
+  result = (security_context_t) ((arg1)->ctx);
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_id_refcnt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *arg1 = (struct security_id *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:security_id_refcnt_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_id_refcnt_set" "', argument " "1"" of type '" "struct security_id *""'"); 
+  }
+  arg1 = (struct security_id *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "security_id_refcnt_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->refcnt = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_security_id_refcnt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *arg1 = (struct security_id *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:security_id_refcnt_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "security_id_refcnt_get" "', argument " "1"" of type '" "struct security_id *""'"); 
+  }
+  arg1 = (struct security_id *)(argp1);
+  result = (unsigned int) ((arg1)->refcnt);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_security_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_security_id")) SWIG_fail;
+  result = (struct security_id *)calloc(1, sizeof(struct security_id));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_security_id, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_security_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct security_id *arg1 = (struct security_id *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_security_id",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_security_id" "', argument " "1"" of type '" "struct security_id *""'"); 
+  }
+  arg1 = (struct security_id *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *security_id_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_security_id, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_sid_to_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_sid_to_context",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_sid_to_context" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  result = (int)avc_sid_to_context(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_sid_to_context_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  security_context_t temp2 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_sid_to_context_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_sid_to_context_raw" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  result = (int)avc_sid_to_context_raw(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_context_to_sid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_id_t *arg2 = (security_id_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_id_t temp2 ;
+  PyObject * obj0 = 0 ;
+  
+  {
+    arg2 = &temp2;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_context_to_sid",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_context_to_sid" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)avc_context_to_sid(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    if (*arg2) {
+      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj(*arg2, SWIGTYPE_p_security_id, 0));
+    } else {
+      Py_INCREF(Py_None);
+      resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+    }
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_context_to_sid_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_context_t arg1 = (security_context_t) 0 ;
+  security_id_t *arg2 = (security_id_t *) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  security_id_t temp2 ;
+  PyObject * obj0 = 0 ;
+  
+  {
+    arg2 = &temp2;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_context_to_sid_raw",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_context_to_sid_raw" "', argument " "1"" of type '" "security_context_t""'");
+  }
+  arg1 = (security_context_t)(buf1);
+  result = (int)avc_context_to_sid_raw(arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    if (*arg2) {
+      resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj(*arg2, SWIGTYPE_p_security_id, 0));
+    } else {
+      Py_INCREF(Py_None);
+      resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+    }
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_sidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:sidget",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sidget" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  result = (int)sidget(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_sidput(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:sidput",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sidput" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  result = (int)sidput(arg1);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_entry_ref_ae_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_entry_ref *arg1 = (struct avc_entry_ref *) 0 ;
+  struct avc_entry *arg2 = (struct avc_entry *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_entry_ref_ae_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_entry_ref, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_entry_ref_ae_set" "', argument " "1"" of type '" "struct avc_entry_ref *""'"); 
+  }
+  arg1 = (struct avc_entry_ref *)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_avc_entry, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "avc_entry_ref_ae_set" "', argument " "2"" of type '" "struct avc_entry *""'"); 
+  }
+  arg2 = (struct avc_entry *)(argp2);
+  if (arg1) (arg1)->ae = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_entry_ref_ae_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_entry_ref *arg1 = (struct avc_entry_ref *) 0 ;
+  struct avc_entry *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_entry_ref_ae_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_entry_ref, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_entry_ref_ae_get" "', argument " "1"" of type '" "struct avc_entry_ref *""'"); 
+  }
+  arg1 = (struct avc_entry_ref *)(argp1);
+  result = (struct avc_entry *) ((arg1)->ae);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_entry, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_avc_entry_ref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_entry_ref *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_entry_ref")) SWIG_fail;
+  result = (struct avc_entry_ref *)calloc(1, sizeof(struct avc_entry_ref));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_entry_ref, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_avc_entry_ref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_entry_ref *arg1 = (struct avc_entry_ref *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_entry_ref",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_entry_ref, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_entry_ref" "', argument " "1"" of type '" "struct avc_entry_ref *""'"); 
+  }
+  arg1 = (struct avc_entry_ref *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *avc_entry_ref_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_entry_ref, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_memory_callback_func_malloc_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *arg1 = (struct avc_memory_callback *) 0 ;
+  void *(*arg2)(size_t) = (void *(*)(size_t)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_memory_callback_func_malloc_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_memory_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_memory_callback_func_malloc_set" "', argument " "1"" of type '" "struct avc_memory_callback *""'"); 
+  }
+  arg1 = (struct avc_memory_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_size_t__p_void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_memory_callback_func_malloc_set" "', argument " "2"" of type '" "void *(*)(size_t)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_malloc = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_memory_callback_func_malloc_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *arg1 = (struct avc_memory_callback *) 0 ;
+  void *(*result)(size_t) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_memory_callback_func_malloc_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_memory_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_memory_callback_func_malloc_get" "', argument " "1"" of type '" "struct avc_memory_callback *""'"); 
+  }
+  arg1 = (struct avc_memory_callback *)(argp1);
+  result = (void *(*)(size_t)) ((arg1)->func_malloc);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_size_t__p_void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_memory_callback_func_free_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *arg1 = (struct avc_memory_callback *) 0 ;
+  void (*arg2)(void *) = (void (*)(void *)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_memory_callback_func_free_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_memory_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_memory_callback_func_free_set" "', argument " "1"" of type '" "struct avc_memory_callback *""'"); 
+  }
+  arg1 = (struct avc_memory_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_memory_callback_func_free_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_free = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_memory_callback_func_free_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *arg1 = (struct avc_memory_callback *) 0 ;
+  void (*result)(void *) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_memory_callback_func_free_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_memory_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_memory_callback_func_free_get" "', argument " "1"" of type '" "struct avc_memory_callback *""'"); 
+  }
+  arg1 = (struct avc_memory_callback *)(argp1);
+  result = (void (*)(void *)) ((arg1)->func_free);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_avc_memory_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_memory_callback")) SWIG_fail;
+  result = (struct avc_memory_callback *)calloc(1, sizeof(struct avc_memory_callback));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_memory_callback, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_avc_memory_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_memory_callback *arg1 = (struct avc_memory_callback *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_memory_callback",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_memory_callback, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_memory_callback" "', argument " "1"" of type '" "struct avc_memory_callback *""'"); 
+  }
+  arg1 = (struct avc_memory_callback *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *avc_memory_callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_memory_callback, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_log_callback_func_log_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *arg1 = (struct avc_log_callback *) 0 ;
+  void (*arg2)(char const *,...) = (void (*)(char const *,...)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_log_callback_func_log_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_log_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_log_callback_func_log_set" "', argument " "1"" of type '" "struct avc_log_callback *""'"); 
+  }
+  arg1 = (struct avc_log_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_q_const__char_v_______void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_log_callback_func_log_set" "', argument " "2"" of type '" "void (*)(char const *,...)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_log = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_log_callback_func_log_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *arg1 = (struct avc_log_callback *) 0 ;
+  void (*result)(char const *,...) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_log_callback_func_log_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_log_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_log_callback_func_log_get" "', argument " "1"" of type '" "struct avc_log_callback *""'"); 
+  }
+  arg1 = (struct avc_log_callback *)(argp1);
+  result = (void (*)(char const *,...)) ((arg1)->func_log);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_q_const__char_v_______void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_log_callback_func_audit_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *arg1 = (struct avc_log_callback *) 0 ;
+  void (*arg2)(void *,security_class_t,char *,size_t) = (void (*)(void *,security_class_t,char *,size_t)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_log_callback_func_audit_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_log_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_log_callback_func_audit_set" "', argument " "1"" of type '" "struct avc_log_callback *""'"); 
+  }
+  arg1 = (struct avc_log_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_unsigned_short_p_char_size_t__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_log_callback_func_audit_set" "', argument " "2"" of type '" "void (*)(void *,security_class_t,char *,size_t)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_audit = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_log_callback_func_audit_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *arg1 = (struct avc_log_callback *) 0 ;
+  void (*result)(void *,security_class_t,char *,size_t) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_log_callback_func_audit_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_log_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_log_callback_func_audit_get" "', argument " "1"" of type '" "struct avc_log_callback *""'"); 
+  }
+  arg1 = (struct avc_log_callback *)(argp1);
+  result = (void (*)(void *,security_class_t,char *,size_t)) ((arg1)->func_audit);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_unsigned_short_p_char_size_t__void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_avc_log_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_log_callback")) SWIG_fail;
+  result = (struct avc_log_callback *)calloc(1, sizeof(struct avc_log_callback));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_log_callback, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_avc_log_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_log_callback *arg1 = (struct avc_log_callback *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_log_callback",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_log_callback, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_log_callback" "', argument " "1"" of type '" "struct avc_log_callback *""'"); 
+  }
+  arg1 = (struct avc_log_callback *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *avc_log_callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_log_callback, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_thread_callback_func_create_thread_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *arg1 = (struct avc_thread_callback *) 0 ;
+  void *(*arg2)(void (*)(void)) = (void *(*)(void (*)(void))) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_thread_callback_func_create_thread_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_thread_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_thread_callback_func_create_thread_set" "', argument " "1"" of type '" "struct avc_thread_callback *""'"); 
+  }
+  arg1 = (struct avc_thread_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_f_void__void__p_void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_thread_callback_func_create_thread_set" "', argument " "2"" of type '" "void *(*)(void (*)(void))""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_create_thread = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_thread_callback_func_create_thread_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *arg1 = (struct avc_thread_callback *) 0 ;
+  void *(*result)(void (*)(void)) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_thread_callback_func_create_thread_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_thread_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_thread_callback_func_create_thread_get" "', argument " "1"" of type '" "struct avc_thread_callback *""'"); 
+  }
+  arg1 = (struct avc_thread_callback *)(argp1);
+  result = (void *(*)(void (*)(void))) ((arg1)->func_create_thread);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_f_void__void__p_void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_thread_callback_func_stop_thread_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *arg1 = (struct avc_thread_callback *) 0 ;
+  void (*arg2)(void *) = (void (*)(void *)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_thread_callback_func_stop_thread_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_thread_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_thread_callback_func_stop_thread_set" "', argument " "1"" of type '" "struct avc_thread_callback *""'"); 
+  }
+  arg1 = (struct avc_thread_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_thread_callback_func_stop_thread_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_stop_thread = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_thread_callback_func_stop_thread_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *arg1 = (struct avc_thread_callback *) 0 ;
+  void (*result)(void *) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_thread_callback_func_stop_thread_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_thread_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_thread_callback_func_stop_thread_get" "', argument " "1"" of type '" "struct avc_thread_callback *""'"); 
+  }
+  arg1 = (struct avc_thread_callback *)(argp1);
+  result = (void (*)(void *)) ((arg1)->func_stop_thread);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_avc_thread_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_thread_callback")) SWIG_fail;
+  result = (struct avc_thread_callback *)calloc(1, sizeof(struct avc_thread_callback));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_thread_callback, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_avc_thread_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_thread_callback *arg1 = (struct avc_thread_callback *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_thread_callback",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_thread_callback, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_thread_callback" "', argument " "1"" of type '" "struct avc_thread_callback *""'"); 
+  }
+  arg1 = (struct avc_thread_callback *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *avc_thread_callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_thread_callback, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_alloc_lock_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void *(*arg2)(void) = (void *(*)(void)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_lock_callback_func_alloc_lock_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_alloc_lock_set" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_void__p_void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_lock_callback_func_alloc_lock_set" "', argument " "2"" of type '" "void *(*)(void)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_alloc_lock = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_alloc_lock_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void *(*result)(void) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_lock_callback_func_alloc_lock_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_alloc_lock_get" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  result = (void *(*)(void)) ((arg1)->func_alloc_lock);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_void__p_void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_get_lock_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*arg2)(void *) = (void (*)(void *)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_lock_callback_func_get_lock_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_get_lock_set" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_lock_callback_func_get_lock_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_get_lock = arg2;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_get_lock_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*result)(void *) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_lock_callback_func_get_lock_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_get_lock_get" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  result = (void (*)(void *)) ((arg1)->func_get_lock);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
   return resultobj;
 fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_security_commit_booleans(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_release_lock_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int result;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*arg2)(void *) = (void (*)(void *)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":security_commit_booleans")) SWIG_fail;
-  result = (int)security_commit_booleans();
-  resultobj = SWIG_From_int((int)(result));
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_lock_callback_func_release_lock_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_release_lock_set" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_lock_callback_func_release_lock_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_release_lock = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_set_matchpathcon_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_release_lock_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  unsigned int arg1 ;
-  unsigned int val1 ;
-  int ecode1 = 0 ;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*result)(void *) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:set_matchpathcon_flags",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_matchpathcon_flags" "', argument " "1"" of type '" "unsigned int""'");
-  } 
-  arg1 = (unsigned int)(val1);
-  set_matchpathcon_flags(arg1);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_lock_callback_func_release_lock_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_release_lock_get" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  result = (void (*)(void *)) ((arg1)->func_release_lock);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_free_lock_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*arg2)(void *) = (void (*)(void *)) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_lock_callback_func_free_lock_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_free_lock_set" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  {
+    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "avc_lock_callback_func_free_lock_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
+    }
+  }
+  if (arg1) (arg1)->func_free_lock = arg2;
+  
   resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
@@ -3698,22 +7776,122 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_matchpathcon_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_lock_callback_func_free_lock_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void (*result)(void *) = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_lock_callback_func_free_lock_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_lock_callback_func_free_lock_get" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  result = (void (*)(void *)) ((arg1)->func_free_lock);
+  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_avc_lock_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_lock_callback")) SWIG_fail;
+  result = (struct avc_lock_callback *)calloc(1, sizeof(struct avc_lock_callback));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_lock_callback, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_avc_lock_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_lock_callback *arg1 = (struct avc_lock_callback *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_lock_callback",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_lock_callback, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_lock_callback" "', argument " "1"" of type '" "struct avc_lock_callback *""'"); 
+  }
+  arg1 = (struct avc_lock_callback *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *avc_lock_callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_lock_callback, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
+  struct avc_memory_callback *arg2 = (struct avc_memory_callback *) 0 ;
+  struct avc_log_callback *arg3 = (struct avc_log_callback *) 0 ;
+  struct avc_thread_callback *arg4 = (struct avc_thread_callback *) 0 ;
+  struct avc_lock_callback *arg5 = (struct avc_lock_callback *) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  void *argp3 = 0 ;
+  int res3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:matchpathcon_init",&obj0)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:avc_init",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon_init" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_init" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)matchpathcon_init((char const *)arg1);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_avc_memory_callback, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "avc_init" "', argument " "2"" of type '" "struct avc_memory_callback const *""'"); 
+  }
+  arg2 = (struct avc_memory_callback *)(argp2);
+  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_avc_log_callback, 0 |  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "avc_init" "', argument " "3"" of type '" "struct avc_log_callback const *""'"); 
+  }
+  arg3 = (struct avc_log_callback *)(argp3);
+  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_avc_thread_callback, 0 |  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "avc_init" "', argument " "4"" of type '" "struct avc_thread_callback const *""'"); 
+  }
+  arg4 = (struct avc_thread_callback *)(argp4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_avc_lock_callback, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "avc_init" "', argument " "5"" of type '" "struct avc_lock_callback const *""'"); 
+  }
+  arg5 = (struct avc_lock_callback *)(argp5);
+  result = (int)avc_init((char const *)arg1,(struct avc_memory_callback const *)arg2,(struct avc_log_callback const *)arg3,(struct avc_thread_callback const *)arg4,(struct avc_lock_callback const *)arg5);
   resultobj = SWIG_From_int((int)(result));
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
@@ -3723,577 +7901,1193 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_matchpathcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cleanup(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":avc_cleanup")) SWIG_fail;
+  avc_cleanup();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  mode_t arg2 ;
-  security_context_t *arg3 = (security_context_t *) 0 ;
   int result;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  unsigned int val2 ;
-  int ecode2 = 0 ;
-  security_context_t temp3 ;
-  char *temp30 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":avc_reset")) SWIG_fail;
+  result = (int)avc_reset();
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_destroy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":avc_destroy")) SWIG_fail;
+  avc_destroy();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_has_perm_noaudit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  security_id_t arg2 = (security_id_t) 0 ;
+  security_class_t arg3 ;
+  access_vector_t arg4 ;
+  struct avc_entry_ref *arg5 = (struct avc_entry_ref *) 0 ;
+  struct av_decision *arg6 = (struct av_decision *) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  unsigned int val4 ;
+  int ecode4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  void *argp6 = 0 ;
+  int res6 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
   
-  {
-    arg3 = &temp3;
+  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:avc_has_perm_noaudit",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_has_perm_noaudit" "', argument " "1"" of type '" "security_id_t""'"); 
   }
-  if (!PyArg_ParseTuple(args,(char *)"OO:matchpathcon",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  arg1 = (security_id_t)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "avc_has_perm_noaudit" "', argument " "2"" of type '" "security_id_t""'"); 
+  }
+  arg2 = (security_id_t)(argp2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "avc_has_perm_noaudit" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "avc_has_perm_noaudit" "', argument " "4"" of type '" "access_vector_t""'");
+  } 
+  arg4 = (access_vector_t)(val4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_avc_entry_ref, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "avc_has_perm_noaudit" "', argument " "5"" of type '" "struct avc_entry_ref *""'"); 
+  }
+  arg5 = (struct avc_entry_ref *)(argp5);
+  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "avc_has_perm_noaudit" "', argument " "6"" of type '" "struct av_decision *""'"); 
+  }
+  arg6 = (struct av_decision *)(argp6);
+  result = (int)avc_has_perm_noaudit(arg1,arg2,arg3,arg4,arg5,arg6);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_has_perm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  security_id_t arg2 = (security_id_t) 0 ;
+  security_class_t arg3 ;
+  access_vector_t arg4 ;
+  struct avc_entry_ref *arg5 = (struct avc_entry_ref *) 0 ;
+  void *arg6 = (void *) 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  unsigned int val4 ;
+  int ecode4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  int res6 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:avc_has_perm",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_has_perm" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "avc_has_perm" "', argument " "2"" of type '" "security_id_t""'"); 
+  }
+  arg2 = (security_id_t)(argp2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "avc_has_perm" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "avc_has_perm" "', argument " "4"" of type '" "access_vector_t""'");
+  } 
+  arg4 = (access_vector_t)(val4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_avc_entry_ref, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "avc_has_perm" "', argument " "5"" of type '" "struct avc_entry_ref *""'"); 
+  }
+  arg5 = (struct avc_entry_ref *)(argp5);
+  res6 = SWIG_ConvertPtr(obj5,SWIG_as_voidptrptr(&arg6), 0, 0);
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "avc_has_perm" "', argument " "6"" of type '" "void *""'"); 
+  }
+  result = (int)avc_has_perm(arg1,arg2,arg3,arg4,arg5,arg6);
+  resultobj = SWIG_From_int((int)(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_audit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  security_id_t arg1 = (security_id_t) 0 ;
+  security_id_t arg2 = (security_id_t) 0 ;
+  security_class_t arg3 ;
+  access_vector_t arg4 ;
+  struct av_decision *arg5 = (struct av_decision *) 0 ;
+  int arg6 ;
+  void *arg7 = (void *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  unsigned short val3 ;
+  int ecode3 = 0 ;
+  unsigned int val4 ;
+  int ecode4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  int val6 ;
+  int ecode6 = 0 ;
+  int res7 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
+  PyObject * obj6 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:avc_audit",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_audit" "', argument " "1"" of type '" "security_id_t""'"); 
+  }
+  arg1 = (security_id_t)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_security_id, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "avc_audit" "', argument " "2"" of type '" "security_id_t""'"); 
+  }
+  arg2 = (security_id_t)(argp2);
+  ecode3 = SWIG_AsVal_unsigned_SS_short(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "avc_audit" "', argument " "3"" of type '" "security_class_t""'");
+  } 
+  arg3 = (security_class_t)(val3);
+  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "avc_audit" "', argument " "4"" of type '" "access_vector_t""'");
+  } 
+  arg4 = (access_vector_t)(val4);
+  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_av_decision, 0 |  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "avc_audit" "', argument " "5"" of type '" "struct av_decision *""'"); 
+  }
+  arg5 = (struct av_decision *)(argp5);
+  ecode6 = SWIG_AsVal_int(obj5, &val6);
+  if (!SWIG_IsOK(ecode6)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "avc_audit" "', argument " "6"" of type '" "int""'");
+  } 
+  arg6 = (int)(val6);
+  res7 = SWIG_ConvertPtr(obj6,SWIG_as_voidptrptr(&arg7), 0, 0);
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "avc_audit" "', argument " "7"" of type '" "void *""'"); 
+  }
+  avc_audit(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_lookups_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_entry_lookups_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchpathcon" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_lookups_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
   }
-  arg1 = buf1;
+  arg1 = (struct avc_cache_stats *)(argp1);
   ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "matchpathcon" "', argument " "2"" of type '" "mode_t""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_entry_lookups_set" "', argument " "2"" of type '" "unsigned int""'");
   } 
-  arg2 = (mode_t)(val2);
-  result = (int)matchpathcon((char const *)arg1,arg2,arg3);
-  resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg3)
-    temp30 = *arg3;
-    else
-    temp30 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp30));
-  }
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->entry_lookups = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_matchmediacon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_lookups_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
-  int result;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:matchmediacon",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_entry_lookups_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matchmediacon" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = buf1;
-  result = (int)matchmediacon((char const *)arg1,arg2);
-  resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_lookups_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
   }
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->entry_lookups);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_getenforcemode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_hits_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  int *arg1 = (int *) 0 ;
-  int result;
-  int temp1 ;
-  int res1 = SWIG_TMPOBJ ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  arg1 = &temp1;
-  if (!PyArg_ParseTuple(args,(char *)":selinux_getenforcemode")) SWIG_fail;
-  result = (int)selinux_getenforcemode(arg1);
-  resultobj = SWIG_From_int((int)(result));
-  if (SWIG_IsTmpObj(res1)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg1)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags));
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_entry_hits_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_hits_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
   }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_entry_hits_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->entry_hits = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_policy_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_hits_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_policy_root")) SWIG_fail;
-  result = (char *)selinux_policy_root();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_entry_hits_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_hits_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->entry_hits);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_binary_policy_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_misses_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_binary_policy_path")) SWIG_fail;
-  result = (char *)selinux_binary_policy_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_entry_misses_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_misses_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_entry_misses_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->entry_misses = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_failsafe_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_misses_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_failsafe_context_path")) SWIG_fail;
-  result = (char *)selinux_failsafe_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_entry_misses_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_misses_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->entry_misses);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_removable_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_discards_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_removable_context_path")) SWIG_fail;
-  result = (char *)selinux_removable_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_entry_discards_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_discards_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_entry_discards_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->entry_discards = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_default_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_entry_discards_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_default_context_path")) SWIG_fail;
-  result = (char *)selinux_default_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_entry_discards_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_entry_discards_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->entry_discards);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_user_contexts_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_lookups_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_user_contexts_path")) SWIG_fail;
-  result = (char *)selinux_user_contexts_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_cav_lookups_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_lookups_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_cav_lookups_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->cav_lookups = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_file_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_lookups_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_path")) SWIG_fail;
-  result = (char *)selinux_file_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_cav_lookups_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_lookups_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->cav_lookups);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_file_context_homedir_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_hits_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_homedir_path")) SWIG_fail;
-  result = (char *)selinux_file_context_homedir_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_cav_hits_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_hits_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_cav_hits_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->cav_hits = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_file_context_local_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_hits_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_file_context_local_path")) SWIG_fail;
-  result = (char *)selinux_file_context_local_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_cav_hits_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_hits_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->cav_hits);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_homedir_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_probes_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_homedir_context_path")) SWIG_fail;
-  result = (char *)selinux_homedir_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_cav_probes_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_probes_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_cav_probes_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->cav_probes = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_media_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_probes_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_media_context_path")) SWIG_fail;
-  result = (char *)selinux_media_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_cav_probes_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_probes_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->cav_probes);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_contexts_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_misses_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_contexts_path")) SWIG_fail;
-  result = (char *)selinux_contexts_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"OO:avc_cache_stats_cav_misses_set",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_misses_set" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "avc_cache_stats_cav_misses_set" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = (unsigned int)(val2);
+  if (arg1) (arg1)->cav_misses = arg2;
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_booleans_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_cache_stats_cav_misses_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  unsigned int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_booleans_path")) SWIG_fail;
-  result = (char *)selinux_booleans_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:avc_cache_stats_cav_misses_get",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avc_cache_stats_cav_misses_get" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  result = (unsigned int) ((arg1)->cav_misses);
+  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_customizable_types_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_new_avc_cache_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *result = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_customizable_types_path")) SWIG_fail;
-  result = (char *)selinux_customizable_types_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)":new_avc_cache_stats")) SWIG_fail;
+  result = (struct avc_cache_stats *)calloc(1, sizeof(struct avc_cache_stats));
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_avc_cache_stats, SWIG_POINTER_NEW |  0 );
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_users_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_delete_avc_cache_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  struct avc_cache_stats *arg1 = (struct avc_cache_stats *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_users_path")) SWIG_fail;
-  result = (char *)selinux_users_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_avc_cache_stats",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_avc_cache_stats, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_avc_cache_stats" "', argument " "1"" of type '" "struct avc_cache_stats *""'"); 
+  }
+  arg1 = (struct avc_cache_stats *)(argp1);
+  free((char *) arg1);
+  
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_usersconf_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *avc_cache_stats_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_avc_cache_stats, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_avc_av_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_usersconf_path")) SWIG_fail;
-  result = (char *)selinux_usersconf_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)":avc_av_stats")) SWIG_fail;
+  avc_av_stats();
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_translations_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_avc_sid_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_translations_path")) SWIG_fail;
-  result = (char *)selinux_translations_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)":avc_sid_stats")) SWIG_fail;
+  avc_sid_stats();
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_netfilter_context_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_selinux_default_type_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *result = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_netfilter_context_path")) SWIG_fail;
-  result = (char *)selinux_netfilter_context_path();
-  resultobj = SWIG_FromCharPtr(result);
+  if (!PyArg_ParseTuple(args,(char *)":selinux_default_type_path")) SWIG_fail;
+  result = (char *)selinux_default_type_path();
+  resultobj = SWIG_FromCharPtr((const char *)result);
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_default_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char *result = 0 ;
+  char *arg1 = (char *) 0 ;
+  char **arg2 = (char **) 0 ;
+  int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  char *temp2 = 0 ;
+  PyObject * obj0 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)":selinux_path")) SWIG_fail;
-  result = (char *)selinux_path();
-  resultobj = SWIG_FromCharPtr(result);
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:get_default_type",&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_default_type" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (int)get_default_type((char const *)arg1,arg2);
+  resultobj = SWIG_From_int((int)(result));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    free(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_check_passwd_access(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_ordered_context_list(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  access_vector_t arg1 ;
+  char *arg1 = (char *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_context_t **arg3 = (security_context_t **) 0 ;
   int result;
-  void *argp1 ;
-  int res1 = 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  security_context_t *temp3 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:selinux_check_passwd_access",&obj0)) SWIG_fail;
   {
-    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_access_vector_t,  0 );
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_check_passwd_access" "', argument " "1"" of type '" "access_vector_t""'"); 
-    }  
-    if (!argp1) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "selinux_check_passwd_access" "', argument " "1"" of type '" "access_vector_t""'");
+    arg3 = &temp3;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"OO:get_ordered_context_list",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_ordered_context_list" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_ordered_context_list" "', argument " "2"" of type '" "security_context_t""'");
+  }
+  arg2 = (security_context_t)(buf2);
+  result = (int)get_ordered_context_list((char const *)arg1,arg2,arg3);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    PyObject* plist;
+    int i;
+    
+    if (*arg3) {
+      plist = PyList_New(result);
+      for (i = 0; i < result; i++) {
+        PyList_SetItem(plist, i, PyString_FromString((*arg3)[i]));
+      }
     } else {
-      arg1 = *((access_vector_t *)(argp1));
+      plist = PyList_New(0);
     }
+    /* Only return the Python list, don't need to return the length anymore */
+    resultobj = plist;
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
   }
-  result = (int)selinux_check_passwd_access(arg1);
-  resultobj = SWIG_From_int((int)(result));
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  {
+    if (*arg3) freeconary(*arg3);
+  }
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_checkPasswdAccess(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_ordered_context_list_with_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  access_vector_t arg1 ;
+  char *arg1 = (char *) 0 ;
+  char *arg2 = (char *) 0 ;
+  security_context_t arg3 = (security_context_t) 0 ;
+  security_context_t **arg4 = (security_context_t **) 0 ;
   int result;
-  void *argp1 ;
-  int res1 = 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  security_context_t *temp4 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:checkPasswdAccess",&obj0)) SWIG_fail;
   {
-    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_access_vector_t,  0 );
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "checkPasswdAccess" "', argument " "1"" of type '" "access_vector_t""'"); 
-    }  
-    if (!argp1) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "checkPasswdAccess" "', argument " "1"" of type '" "access_vector_t""'");
+    arg4 = &temp4;
+  }
+  if (!PyArg_ParseTuple(args,(char *)"OOO:get_ordered_context_list_with_level",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_ordered_context_list_with_level" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_ordered_context_list_with_level" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "get_ordered_context_list_with_level" "', argument " "3"" of type '" "security_context_t""'");
+  }
+  arg3 = (security_context_t)(buf3);
+  result = (int)get_ordered_context_list_with_level((char const *)arg1,(char const *)arg2,arg3,arg4);
+  resultobj = SWIG_From_int((int)(result));
+  {
+    PyObject* plist;
+    int i;
+    
+    if (*arg4) {
+      plist = PyList_New(result);
+      for (i = 0; i < result; i++) {
+        PyList_SetItem(plist, i, PyString_FromString((*arg4)[i]));
+      }
     } else {
-      arg1 = *((access_vector_t *)(argp1));
+      plist = PyList_New(0);
     }
+    /* Only return the Python list, don't need to return the length anymore */
+    resultobj = plist;
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  {
+    if (*arg4) freeconary(*arg4);
   }
-  result = (int)checkPasswdAccess(arg1);
-  resultobj = SWIG_From_int((int)(result));
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  {
+    if (*arg4) freeconary(*arg4);
+  }
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_rpm_execcon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_default_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  unsigned int arg1 ;
-  char *arg2 = (char *) 0 ;
-  char **arg3 ;
-  char **arg4 ;
+  char *arg1 = (char *) 0 ;
+  security_context_t arg2 = (security_context_t) 0 ;
+  security_context_t *arg3 = (security_context_t *) 0 ;
   int result;
-  unsigned int val1 ;
-  int ecode1 = 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
+  security_context_t temp3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:rpm_execcon",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "rpm_execcon" "', argument " "1"" of type '" "unsigned int""'");
-  } 
-  arg1 = (unsigned int)(val1);
+  arg3 = &temp3;
+  if (!PyArg_ParseTuple(args,(char *)"OO:get_default_context",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_default_context" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
   res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "rpm_execcon" "', argument " "2"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_default_context" "', argument " "2"" of type '" "security_context_t""'");
   }
-  arg2 = buf2;
-  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_p_char, 0 |  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rpm_execcon" "', argument " "3"" of type '" "char *const []""'"); 
-  } 
-  arg3 = (char **)(argp3);
-  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_char, 0 |  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "rpm_execcon" "', argument " "4"" of type '" "char *const []""'"); 
-  } 
-  arg4 = (char **)(argp4);
-  result = (int)rpm_execcon(arg1,(char const *)arg2,(char *const (*))arg3,(char *const (*))arg4);
+  arg2 = (security_context_t)(buf2);
+  result = (int)get_default_context((char const *)arg1,arg2,arg3);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg3) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg3));
+    freecon(*arg3);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_is_context_customizable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_default_context_with_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  security_context_t arg1 ;
+  char *arg1 = (char *) 0 ;
+  char *arg2 = (char *) 0 ;
+  security_context_t arg3 = (security_context_t) 0 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
   int result;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  security_context_t temp4 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"O:is_context_customizable",&obj0)) SWIG_fail;
-  {
-    arg1 = (security_context_t)PyString_AsString(obj0);
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:get_default_context_with_level",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_default_context_with_level" "', argument " "1"" of type '" "char const *""'");
   }
-  result = (int)is_context_customizable(arg1);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_default_context_with_level" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "get_default_context_with_level" "', argument " "3"" of type '" "security_context_t""'");
+  }
+  arg3 = (security_context_t)(buf3);
+  result = (int)get_default_context_with_level((char const *)arg1,(char const *)arg2,arg3,arg4);
   resultobj = SWIG_From_int((int)(result));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_trans_to_raw_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_default_context_with_role(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
+  char *arg2 = (char *) 0 ;
+  security_context_t arg3 = (security_context_t) 0 ;
+  security_context_t *arg4 = (security_context_t *) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  security_context_t temp4 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:selinux_trans_to_raw_context",&obj0)) SWIG_fail;
+  arg4 = &temp4;
+  if (!PyArg_ParseTuple(args,(char *)"OOO:get_default_context_with_role",&obj0,&obj1,&obj2)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_trans_to_raw_context" "', argument " "1"" of type '" "char *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_default_context_with_role" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)selinux_trans_to_raw_context(arg1,arg2);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_default_context_with_role" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "get_default_context_with_role" "', argument " "3"" of type '" "security_context_t""'");
+  }
+  arg3 = (security_context_t)(buf3);
+  result = (int)get_default_context_with_role((char const *)arg1,(char const *)arg2,arg3,arg4);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  if (*arg4) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg4));
+    freecon(*arg4);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
   return resultobj;
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_raw_to_trans_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_get_default_context_with_rolelevel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
-  security_context_t *arg2 = (security_context_t *) 0 ;
+  char *arg2 = (char *) 0 ;
+  char *arg3 = (char *) 0 ;
+  security_context_t arg4 = (security_context_t) 0 ;
+  security_context_t *arg5 = (security_context_t *) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  security_context_t temp2 ;
-  char *temp20 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  int res4 ;
+  char *buf4 = 0 ;
+  int alloc4 = 0 ;
+  security_context_t temp5 = 0 ;
   PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:selinux_raw_to_trans_context",&obj0)) SWIG_fail;
+  arg5 = &temp5;
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:get_default_context_with_rolelevel",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "selinux_raw_to_trans_context" "', argument " "1"" of type '" "char *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_default_context_with_rolelevel" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)selinux_raw_to_trans_context(arg1,arg2);
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "get_default_context_with_rolelevel" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "get_default_context_with_rolelevel" "', argument " "3"" of type '" "char const *""'");
+  }
+  arg3 = (char *)(buf3);
+  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "get_default_context_with_rolelevel" "', argument " "4"" of type '" "security_context_t""'");
+  }
+  arg4 = (security_context_t)(buf4);
+  result = (int)get_default_context_with_rolelevel((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
   resultobj = SWIG_From_int((int)(result));
-  {
-    if (*arg2)
-    temp20 = *arg2;
-    else
-    temp20 = "";
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(temp20));
+  if (*arg5) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg5));
+    freecon(*arg5);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
   return resultobj;
 fail:
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
+  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_selinux_getpolicytype(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_query_user_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
-  char **arg1 = (char **) 0 ;
+  security_context_t *arg1 = (security_context_t *) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
-  char *temp1 ;
+  security_context_t temp1 = 0 ;
+  security_context_t temp2 = 0 ;
   
-  {
-    arg1 = &temp1;
-  }
-  if (!PyArg_ParseTuple(args,(char *)":selinux_getpolicytype")) SWIG_fail;
-  result = (int)selinux_getpolicytype(arg1);
+  arg1 = &temp1;
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)":query_user_context")) SWIG_fail;
+  result = (int)query_user_context(arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
-  {
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(*arg1));
+  if (*arg1) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg1));
+    freecon(*arg1);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
+  }
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   return resultobj;
 fail:
@@ -4301,38 +9095,33 @@
 }
 
 
-SWIGINTERN PyObject *_wrap_getseuserbyname(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+SWIGINTERN PyObject *_wrap_manual_user_enter_context(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *resultobj = 0;
   char *arg1 = (char *) 0 ;
-  char **arg2 = (char **) 0 ;
-  char **arg3 = (char **) 0 ;
+  security_context_t *arg2 = (security_context_t *) 0 ;
   int result;
   int res1 ;
   char *buf1 = 0 ;
   int alloc1 = 0 ;
-  char *temp2 ;
-  char *temp3 ;
+  security_context_t temp2 = 0 ;
   PyObject * obj0 = 0 ;
   
-  {
-    arg2 = &temp2;
-  }
-  {
-    arg3 = &temp3;
-  }
-  if (!PyArg_ParseTuple(args,(char *)"O:getseuserbyname",&obj0)) SWIG_fail;
+  arg2 = &temp2;
+  if (!PyArg_ParseTuple(args,(char *)"O:manual_user_enter_context",&obj0)) SWIG_fail;
   res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getseuserbyname" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "manual_user_enter_context" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = buf1;
-  result = (int)getseuserbyname((char const *)arg1,arg2,arg3);
+  arg1 = (char *)(buf1);
+  result = (int)manual_user_enter_context((char const *)arg1,arg2);
   resultobj = SWIG_From_int((int)(result));
-  {
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(*arg2));
-  }
-  {
-    resultobj = SWIG_Python_AppendOutput(resultobj, PyString_FromString(*arg3));
+  if (*arg2) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtr(*arg2));
+    freecon(*arg2);
+  }
+  else {
+    Py_INCREF(Py_None);
+    resultobj = SWIG_Python_AppendOutput(resultobj, Py_None);
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
@@ -4346,43 +9135,107 @@
 	 { (char *)"is_selinux_enabled", _wrap_is_selinux_enabled, METH_VARARGS, NULL},
 	 { (char *)"is_selinux_mls_enabled", _wrap_is_selinux_mls_enabled, METH_VARARGS, NULL},
 	 { (char *)"getcon", _wrap_getcon, METH_VARARGS, NULL},
+	 { (char *)"getcon_raw", _wrap_getcon_raw, METH_VARARGS, NULL},
 	 { (char *)"setcon", _wrap_setcon, METH_VARARGS, NULL},
+	 { (char *)"setcon_raw", _wrap_setcon_raw, METH_VARARGS, NULL},
 	 { (char *)"getpidcon", _wrap_getpidcon, METH_VARARGS, NULL},
+	 { (char *)"getpidcon_raw", _wrap_getpidcon_raw, METH_VARARGS, NULL},
 	 { (char *)"getprevcon", _wrap_getprevcon, METH_VARARGS, NULL},
+	 { (char *)"getprevcon_raw", _wrap_getprevcon_raw, METH_VARARGS, NULL},
 	 { (char *)"getexeccon", _wrap_getexeccon, METH_VARARGS, NULL},
+	 { (char *)"getexeccon_raw", _wrap_getexeccon_raw, METH_VARARGS, NULL},
 	 { (char *)"setexeccon", _wrap_setexeccon, METH_VARARGS, NULL},
+	 { (char *)"setexeccon_raw", _wrap_setexeccon_raw, METH_VARARGS, NULL},
 	 { (char *)"getfscreatecon", _wrap_getfscreatecon, METH_VARARGS, NULL},
+	 { (char *)"getfscreatecon_raw", _wrap_getfscreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"setfscreatecon", _wrap_setfscreatecon, METH_VARARGS, NULL},
+	 { (char *)"setfscreatecon_raw", _wrap_setfscreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"getkeycreatecon", _wrap_getkeycreatecon, METH_VARARGS, NULL},
+	 { (char *)"getkeycreatecon_raw", _wrap_getkeycreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"setkeycreatecon", _wrap_setkeycreatecon, METH_VARARGS, NULL},
+	 { (char *)"setkeycreatecon_raw", _wrap_setkeycreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"getsockcreatecon", _wrap_getsockcreatecon, METH_VARARGS, NULL},
+	 { (char *)"getsockcreatecon_raw", _wrap_getsockcreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"setsockcreatecon", _wrap_setsockcreatecon, METH_VARARGS, NULL},
+	 { (char *)"setsockcreatecon_raw", _wrap_setsockcreatecon_raw, METH_VARARGS, NULL},
 	 { (char *)"getfilecon", _wrap_getfilecon, METH_VARARGS, NULL},
+	 { (char *)"getfilecon_raw", _wrap_getfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"lgetfilecon", _wrap_lgetfilecon, METH_VARARGS, NULL},
+	 { (char *)"lgetfilecon_raw", _wrap_lgetfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"fgetfilecon", _wrap_fgetfilecon, METH_VARARGS, NULL},
+	 { (char *)"fgetfilecon_raw", _wrap_fgetfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"setfilecon", _wrap_setfilecon, METH_VARARGS, NULL},
+	 { (char *)"setfilecon_raw", _wrap_setfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"lsetfilecon", _wrap_lsetfilecon, METH_VARARGS, NULL},
+	 { (char *)"lsetfilecon_raw", _wrap_lsetfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"fsetfilecon", _wrap_fsetfilecon, METH_VARARGS, NULL},
+	 { (char *)"fsetfilecon_raw", _wrap_fsetfilecon_raw, METH_VARARGS, NULL},
 	 { (char *)"getpeercon", _wrap_getpeercon, METH_VARARGS, NULL},
+	 { (char *)"getpeercon_raw", _wrap_getpeercon_raw, METH_VARARGS, NULL},
+	 { (char *)"av_decision_allowed_set", _wrap_av_decision_allowed_set, METH_VARARGS, NULL},
+	 { (char *)"av_decision_allowed_get", _wrap_av_decision_allowed_get, METH_VARARGS, NULL},
+	 { (char *)"av_decision_decided_set", _wrap_av_decision_decided_set, METH_VARARGS, NULL},
+	 { (char *)"av_decision_decided_get", _wrap_av_decision_decided_get, METH_VARARGS, NULL},
+	 { (char *)"av_decision_auditallow_set", _wrap_av_decision_auditallow_set, METH_VARARGS, NULL},
+	 { (char *)"av_decision_auditallow_get", _wrap_av_decision_auditallow_get, METH_VARARGS, NULL},
+	 { (char *)"av_decision_auditdeny_set", _wrap_av_decision_auditdeny_set, METH_VARARGS, NULL},
+	 { (char *)"av_decision_auditdeny_get", _wrap_av_decision_auditdeny_get, METH_VARARGS, NULL},
+	 { (char *)"av_decision_seqno_set", _wrap_av_decision_seqno_set, METH_VARARGS, NULL},
+	 { (char *)"av_decision_seqno_get", _wrap_av_decision_seqno_get, METH_VARARGS, NULL},
+	 { (char *)"new_av_decision", _wrap_new_av_decision, METH_VARARGS, NULL},
+	 { (char *)"delete_av_decision", _wrap_delete_av_decision, METH_VARARGS, NULL},
+	 { (char *)"av_decision_swigregister", av_decision_swigregister, METH_VARARGS, NULL},
+	 { (char *)"security_compute_av", _wrap_security_compute_av, METH_VARARGS, NULL},
+	 { (char *)"security_compute_av_raw", _wrap_security_compute_av_raw, METH_VARARGS, NULL},
+	 { (char *)"security_compute_create", _wrap_security_compute_create, METH_VARARGS, NULL},
+	 { (char *)"security_compute_create_raw", _wrap_security_compute_create_raw, METH_VARARGS, NULL},
+	 { (char *)"security_compute_relabel", _wrap_security_compute_relabel, METH_VARARGS, NULL},
+	 { (char *)"security_compute_relabel_raw", _wrap_security_compute_relabel_raw, METH_VARARGS, NULL},
+	 { (char *)"security_compute_member", _wrap_security_compute_member, METH_VARARGS, NULL},
+	 { (char *)"security_compute_member_raw", _wrap_security_compute_member_raw, METH_VARARGS, NULL},
+	 { (char *)"security_compute_user", _wrap_security_compute_user, METH_VARARGS, NULL},
+	 { (char *)"security_compute_user_raw", _wrap_security_compute_user_raw, METH_VARARGS, NULL},
+	 { (char *)"security_load_policy", _wrap_security_load_policy, METH_VARARGS, NULL},
 	 { (char *)"selinux_mkload_policy", _wrap_selinux_mkload_policy, METH_VARARGS, NULL},
 	 { (char *)"selinux_init_load_policy", _wrap_selinux_init_load_policy, METH_VARARGS, NULL},
+	 { (char *)"SELboolean_name_set", _wrap_SELboolean_name_set, METH_VARARGS, NULL},
+	 { (char *)"SELboolean_name_get", _wrap_SELboolean_name_get, METH_VARARGS, NULL},
+	 { (char *)"SELboolean_value_set", _wrap_SELboolean_value_set, METH_VARARGS, NULL},
+	 { (char *)"SELboolean_value_get", _wrap_SELboolean_value_get, METH_VARARGS, NULL},
+	 { (char *)"new_SELboolean", _wrap_new_SELboolean, METH_VARARGS, NULL},
+	 { (char *)"delete_SELboolean", _wrap_delete_SELboolean, METH_VARARGS, NULL},
+	 { (char *)"SELboolean_swigregister", SELboolean_swigregister, METH_VARARGS, NULL},
 	 { (char *)"security_set_boolean_list", _wrap_security_set_boolean_list, METH_VARARGS, NULL},
 	 { (char *)"security_load_booleans", _wrap_security_load_booleans, METH_VARARGS, NULL},
 	 { (char *)"security_check_context", _wrap_security_check_context, METH_VARARGS, NULL},
+	 { (char *)"security_check_context_raw", _wrap_security_check_context_raw, METH_VARARGS, NULL},
 	 { (char *)"security_canonicalize_context", _wrap_security_canonicalize_context, METH_VARARGS, NULL},
+	 { (char *)"security_canonicalize_context_raw", _wrap_security_canonicalize_context_raw, METH_VARARGS, NULL},
 	 { (char *)"security_getenforce", _wrap_security_getenforce, METH_VARARGS, NULL},
 	 { (char *)"security_setenforce", _wrap_security_setenforce, METH_VARARGS, NULL},
+	 { (char *)"security_disable", _wrap_security_disable, METH_VARARGS, NULL},
 	 { (char *)"security_policyvers", _wrap_security_policyvers, METH_VARARGS, NULL},
 	 { (char *)"security_get_boolean_names", _wrap_security_get_boolean_names, METH_VARARGS, NULL},
 	 { (char *)"security_get_boolean_pending", _wrap_security_get_boolean_pending, METH_VARARGS, NULL},
 	 { (char *)"security_get_boolean_active", _wrap_security_get_boolean_active, METH_VARARGS, NULL},
 	 { (char *)"security_set_boolean", _wrap_security_set_boolean, METH_VARARGS, NULL},
 	 { (char *)"security_commit_booleans", _wrap_security_commit_booleans, METH_VARARGS, NULL},
+	 { (char *)"string_to_security_class", _wrap_string_to_security_class, METH_VARARGS, NULL},
+	 { (char *)"string_to_av_perm", _wrap_string_to_av_perm, METH_VARARGS, NULL},
+	 { (char *)"print_access_vector", _wrap_print_access_vector, METH_VARARGS, NULL},
 	 { (char *)"set_matchpathcon_flags", _wrap_set_matchpathcon_flags, METH_VARARGS, NULL},
 	 { (char *)"matchpathcon_init", _wrap_matchpathcon_init, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_init_prefix", _wrap_matchpathcon_init_prefix, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_fini", _wrap_matchpathcon_fini, METH_VARARGS, NULL},
 	 { (char *)"matchpathcon", _wrap_matchpathcon, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_index", _wrap_matchpathcon_index, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_filespec_add", _wrap_matchpathcon_filespec_add, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_filespec_destroy", _wrap_matchpathcon_filespec_destroy, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_filespec_eval", _wrap_matchpathcon_filespec_eval, METH_VARARGS, NULL},
+	 { (char *)"matchpathcon_checkmatches", _wrap_matchpathcon_checkmatches, METH_VARARGS, NULL},
 	 { (char *)"matchmediacon", _wrap_matchmediacon, METH_VARARGS, NULL},
 	 { (char *)"selinux_getenforcemode", _wrap_selinux_getenforcemode, METH_VARARGS, NULL},
+	 { (char *)"selinux_getpolicytype", _wrap_selinux_getpolicytype, METH_VARARGS, NULL},
 	 { (char *)"selinux_policy_root", _wrap_selinux_policy_root, METH_VARARGS, NULL},
 	 { (char *)"selinux_binary_policy_path", _wrap_selinux_binary_policy_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_failsafe_context_path", _wrap_selinux_failsafe_context_path, METH_VARARGS, NULL},
@@ -4395,6 +9248,7 @@
 	 { (char *)"selinux_homedir_context_path", _wrap_selinux_homedir_context_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_media_context_path", _wrap_selinux_media_context_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_contexts_path", _wrap_selinux_contexts_path, METH_VARARGS, NULL},
+	 { (char *)"selinux_securetty_types_path", _wrap_selinux_securetty_types_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_booleans_path", _wrap_selinux_booleans_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_customizable_types_path", _wrap_selinux_customizable_types_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_users_path", _wrap_selinux_users_path, METH_VARARGS, NULL},
@@ -4404,12 +9258,104 @@
 	 { (char *)"selinux_path", _wrap_selinux_path, METH_VARARGS, NULL},
 	 { (char *)"selinux_check_passwd_access", _wrap_selinux_check_passwd_access, METH_VARARGS, NULL},
 	 { (char *)"checkPasswdAccess", _wrap_checkPasswdAccess, METH_VARARGS, NULL},
+	 { (char *)"selinux_check_securetty_context", _wrap_selinux_check_securetty_context, METH_VARARGS, NULL},
+	 { (char *)"set_selinuxmnt", _wrap_set_selinuxmnt, METH_VARARGS, NULL},
 	 { (char *)"rpm_execcon", _wrap_rpm_execcon, METH_VARARGS, NULL},
 	 { (char *)"is_context_customizable", _wrap_is_context_customizable, METH_VARARGS, NULL},
 	 { (char *)"selinux_trans_to_raw_context", _wrap_selinux_trans_to_raw_context, METH_VARARGS, NULL},
 	 { (char *)"selinux_raw_to_trans_context", _wrap_selinux_raw_to_trans_context, METH_VARARGS, NULL},
-	 { (char *)"selinux_getpolicytype", _wrap_selinux_getpolicytype, METH_VARARGS, NULL},
 	 { (char *)"getseuserbyname", _wrap_getseuserbyname, METH_VARARGS, NULL},
+	 { (char *)"selinux_file_context_cmp", _wrap_selinux_file_context_cmp, METH_VARARGS, NULL},
+	 { (char *)"selinux_file_context_verify", _wrap_selinux_file_context_verify, METH_VARARGS, NULL},
+	 { (char *)"selinux_lsetfilecon_default", _wrap_selinux_lsetfilecon_default, METH_VARARGS, NULL},
+	 { (char *)"security_id_ctx_set", _wrap_security_id_ctx_set, METH_VARARGS, NULL},
+	 { (char *)"security_id_ctx_get", _wrap_security_id_ctx_get, METH_VARARGS, NULL},
+	 { (char *)"security_id_refcnt_set", _wrap_security_id_refcnt_set, METH_VARARGS, NULL},
+	 { (char *)"security_id_refcnt_get", _wrap_security_id_refcnt_get, METH_VARARGS, NULL},
+	 { (char *)"new_security_id", _wrap_new_security_id, METH_VARARGS, NULL},
+	 { (char *)"delete_security_id", _wrap_delete_security_id, METH_VARARGS, NULL},
+	 { (char *)"security_id_swigregister", security_id_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_sid_to_context", _wrap_avc_sid_to_context, METH_VARARGS, NULL},
+	 { (char *)"avc_sid_to_context_raw", _wrap_avc_sid_to_context_raw, METH_VARARGS, NULL},
+	 { (char *)"avc_context_to_sid", _wrap_avc_context_to_sid, METH_VARARGS, NULL},
+	 { (char *)"avc_context_to_sid_raw", _wrap_avc_context_to_sid_raw, METH_VARARGS, NULL},
+	 { (char *)"sidget", _wrap_sidget, METH_VARARGS, NULL},
+	 { (char *)"sidput", _wrap_sidput, METH_VARARGS, NULL},
+	 { (char *)"avc_entry_ref_ae_set", _wrap_avc_entry_ref_ae_set, METH_VARARGS, NULL},
+	 { (char *)"avc_entry_ref_ae_get", _wrap_avc_entry_ref_ae_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_entry_ref", _wrap_new_avc_entry_ref, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_entry_ref", _wrap_delete_avc_entry_ref, METH_VARARGS, NULL},
+	 { (char *)"avc_entry_ref_swigregister", avc_entry_ref_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_memory_callback_func_malloc_set", _wrap_avc_memory_callback_func_malloc_set, METH_VARARGS, NULL},
+	 { (char *)"avc_memory_callback_func_malloc_get", _wrap_avc_memory_callback_func_malloc_get, METH_VARARGS, NULL},
+	 { (char *)"avc_memory_callback_func_free_set", _wrap_avc_memory_callback_func_free_set, METH_VARARGS, NULL},
+	 { (char *)"avc_memory_callback_func_free_get", _wrap_avc_memory_callback_func_free_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_memory_callback", _wrap_new_avc_memory_callback, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_memory_callback", _wrap_delete_avc_memory_callback, METH_VARARGS, NULL},
+	 { (char *)"avc_memory_callback_swigregister", avc_memory_callback_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_log_callback_func_log_set", _wrap_avc_log_callback_func_log_set, METH_VARARGS, NULL},
+	 { (char *)"avc_log_callback_func_log_get", _wrap_avc_log_callback_func_log_get, METH_VARARGS, NULL},
+	 { (char *)"avc_log_callback_func_audit_set", _wrap_avc_log_callback_func_audit_set, METH_VARARGS, NULL},
+	 { (char *)"avc_log_callback_func_audit_get", _wrap_avc_log_callback_func_audit_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_log_callback", _wrap_new_avc_log_callback, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_log_callback", _wrap_delete_avc_log_callback, METH_VARARGS, NULL},
+	 { (char *)"avc_log_callback_swigregister", avc_log_callback_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_thread_callback_func_create_thread_set", _wrap_avc_thread_callback_func_create_thread_set, METH_VARARGS, NULL},
+	 { (char *)"avc_thread_callback_func_create_thread_get", _wrap_avc_thread_callback_func_create_thread_get, METH_VARARGS, NULL},
+	 { (char *)"avc_thread_callback_func_stop_thread_set", _wrap_avc_thread_callback_func_stop_thread_set, METH_VARARGS, NULL},
+	 { (char *)"avc_thread_callback_func_stop_thread_get", _wrap_avc_thread_callback_func_stop_thread_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_thread_callback", _wrap_new_avc_thread_callback, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_thread_callback", _wrap_delete_avc_thread_callback, METH_VARARGS, NULL},
+	 { (char *)"avc_thread_callback_swigregister", avc_thread_callback_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_alloc_lock_set", _wrap_avc_lock_callback_func_alloc_lock_set, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_alloc_lock_get", _wrap_avc_lock_callback_func_alloc_lock_get, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_get_lock_set", _wrap_avc_lock_callback_func_get_lock_set, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_get_lock_get", _wrap_avc_lock_callback_func_get_lock_get, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_release_lock_set", _wrap_avc_lock_callback_func_release_lock_set, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_release_lock_get", _wrap_avc_lock_callback_func_release_lock_get, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_free_lock_set", _wrap_avc_lock_callback_func_free_lock_set, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_func_free_lock_get", _wrap_avc_lock_callback_func_free_lock_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_lock_callback", _wrap_new_avc_lock_callback, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_lock_callback", _wrap_delete_avc_lock_callback, METH_VARARGS, NULL},
+	 { (char *)"avc_lock_callback_swigregister", avc_lock_callback_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_init", _wrap_avc_init, METH_VARARGS, NULL},
+	 { (char *)"avc_cleanup", _wrap_avc_cleanup, METH_VARARGS, NULL},
+	 { (char *)"avc_reset", _wrap_avc_reset, METH_VARARGS, NULL},
+	 { (char *)"avc_destroy", _wrap_avc_destroy, METH_VARARGS, NULL},
+	 { (char *)"avc_has_perm_noaudit", _wrap_avc_has_perm_noaudit, METH_VARARGS, NULL},
+	 { (char *)"avc_has_perm", _wrap_avc_has_perm, METH_VARARGS, NULL},
+	 { (char *)"avc_audit", _wrap_avc_audit, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_lookups_set", _wrap_avc_cache_stats_entry_lookups_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_lookups_get", _wrap_avc_cache_stats_entry_lookups_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_hits_set", _wrap_avc_cache_stats_entry_hits_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_hits_get", _wrap_avc_cache_stats_entry_hits_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_misses_set", _wrap_avc_cache_stats_entry_misses_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_misses_get", _wrap_avc_cache_stats_entry_misses_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_discards_set", _wrap_avc_cache_stats_entry_discards_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_entry_discards_get", _wrap_avc_cache_stats_entry_discards_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_lookups_set", _wrap_avc_cache_stats_cav_lookups_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_lookups_get", _wrap_avc_cache_stats_cav_lookups_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_hits_set", _wrap_avc_cache_stats_cav_hits_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_hits_get", _wrap_avc_cache_stats_cav_hits_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_probes_set", _wrap_avc_cache_stats_cav_probes_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_probes_get", _wrap_avc_cache_stats_cav_probes_get, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_misses_set", _wrap_avc_cache_stats_cav_misses_set, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_cav_misses_get", _wrap_avc_cache_stats_cav_misses_get, METH_VARARGS, NULL},
+	 { (char *)"new_avc_cache_stats", _wrap_new_avc_cache_stats, METH_VARARGS, NULL},
+	 { (char *)"delete_avc_cache_stats", _wrap_delete_avc_cache_stats, METH_VARARGS, NULL},
+	 { (char *)"avc_cache_stats_swigregister", avc_cache_stats_swigregister, METH_VARARGS, NULL},
+	 { (char *)"avc_av_stats", _wrap_avc_av_stats, METH_VARARGS, NULL},
+	 { (char *)"avc_sid_stats", _wrap_avc_sid_stats, METH_VARARGS, NULL},
+	 { (char *)"selinux_default_type_path", _wrap_selinux_default_type_path, METH_VARARGS, NULL},
+	 { (char *)"get_default_type", _wrap_get_default_type, METH_VARARGS, NULL},
+	 { (char *)"get_ordered_context_list", _wrap_get_ordered_context_list, METH_VARARGS, NULL},
+	 { (char *)"get_ordered_context_list_with_level", _wrap_get_ordered_context_list_with_level, METH_VARARGS, NULL},
+	 { (char *)"get_default_context", _wrap_get_default_context, METH_VARARGS, NULL},
+	 { (char *)"get_default_context_with_level", _wrap_get_default_context_with_level, METH_VARARGS, NULL},
+	 { (char *)"get_default_context_with_role", _wrap_get_default_context_with_role, METH_VARARGS, NULL},
+	 { (char *)"get_default_context_with_rolelevel", _wrap_get_default_context_with_rolelevel, METH_VARARGS, NULL},
+	 { (char *)"query_user_context", _wrap_query_user_context, METH_VARARGS, NULL},
+	 { (char *)"manual_user_enter_context", _wrap_manual_user_enter_context, METH_VARARGS, NULL},
 	 { NULL, NULL, 0, NULL }
 };
 
@@ -4417,43 +9363,107 @@
 /* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
 
 static swig_type_info _swigt__p_SELboolean = {"_p_SELboolean", "SELboolean *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_access_vector_t = {"_p_access_vector_t", "access_vector_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_av_decision = {"_p_av_decision", "struct av_decision *|av_decision *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_cache_stats = {"_p_avc_cache_stats", "struct avc_cache_stats *|avc_cache_stats *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_entry = {"_p_avc_entry", "struct avc_entry *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_entry_ref = {"_p_avc_entry_ref", "struct avc_entry_ref *|avc_entry_ref *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_lock_callback = {"_p_avc_lock_callback", "struct avc_lock_callback *|avc_lock_callback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_log_callback = {"_p_avc_log_callback", "struct avc_log_callback *|avc_log_callback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_memory_callback = {"_p_avc_memory_callback", "struct avc_memory_callback *|avc_memory_callback *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_avc_thread_callback = {"_p_avc_thread_callback", "struct avc_thread_callback *|avc_thread_callback *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_f_void__void__p_void = {"_p_f_p_f_void__void__p_void", "void *(*)(void (*)(void))", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_q_const__char_v_______void = {"_p_f_p_q_const__char_v_______void", "void (*)(char const *,...)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_void__void = {"_p_f_p_void__void", "void (*)(void *)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_p_void_unsigned_short_p_char_size_t__void = {"_p_f_p_void_unsigned_short_p_char_size_t__void", "void (*)(void *,unsigned short,char *,size_t)|void (*)(void *,security_class_t,char *,size_t)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_size_t__p_void = {"_p_f_size_t__p_void", "void *(*)(size_t)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_f_void__p_void = {"_p_f_void__p_void", "void *(*)(void)", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_ino_t = {"_p_ino_t", "ino_t *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p_p_char = {"_p_p_p_char", "char ***", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_security_context_t = {"_p_security_context_t", "security_context_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *|mode_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **|security_context_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_p_char = {"_p_p_p_char", "char ***|security_context_t **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_security_id = {"_p_p_security_id", "struct security_id **|security_id_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_security_id = {"_p_security_id", "security_id_t|struct security_id *|security_id *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *|access_vector_t *|mode_t *|pid_t *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "security_class_t *|unsigned short *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_SELboolean,
-  &_swigt__p_access_vector_t,
+  &_swigt__p_av_decision,
+  &_swigt__p_avc_cache_stats,
+  &_swigt__p_avc_entry,
+  &_swigt__p_avc_entry_ref,
+  &_swigt__p_avc_lock_callback,
+  &_swigt__p_avc_log_callback,
+  &_swigt__p_avc_memory_callback,
+  &_swigt__p_avc_thread_callback,
   &_swigt__p_char,
+  &_swigt__p_f_p_f_void__void__p_void,
+  &_swigt__p_f_p_q_const__char_v_______void,
+  &_swigt__p_f_p_void__void,
+  &_swigt__p_f_p_void_unsigned_short_p_char_size_t__void,
+  &_swigt__p_f_size_t__p_void,
+  &_swigt__p_f_void__p_void,
+  &_swigt__p_ino_t,
   &_swigt__p_int,
   &_swigt__p_p_char,
   &_swigt__p_p_p_char,
-  &_swigt__p_security_context_t,
+  &_swigt__p_p_security_id,
+  &_swigt__p_security_id,
   &_swigt__p_unsigned_int,
+  &_swigt__p_unsigned_short,
 };
 
 static swig_cast_info _swigc__p_SELboolean[] = {  {&_swigt__p_SELboolean, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_access_vector_t[] = {  {&_swigt__p_access_vector_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_av_decision[] = {  {&_swigt__p_av_decision, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_cache_stats[] = {  {&_swigt__p_avc_cache_stats, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_entry[] = {  {&_swigt__p_avc_entry, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_entry_ref[] = {  {&_swigt__p_avc_entry_ref, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_lock_callback[] = {  {&_swigt__p_avc_lock_callback, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_log_callback[] = {  {&_swigt__p_avc_log_callback, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_memory_callback[] = {  {&_swigt__p_avc_memory_callback, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_avc_thread_callback[] = {  {&_swigt__p_avc_thread_callback, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_p_f_void__void__p_void[] = {  {&_swigt__p_f_p_f_void__void__p_void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_p_q_const__char_v_______void[] = {  {&_swigt__p_f_p_q_const__char_v_______void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_p_void__void[] = {  {&_swigt__p_f_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_p_void_unsigned_short_p_char_size_t__void[] = {  {&_swigt__p_f_p_void_unsigned_short_p_char_size_t__void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_size_t__p_void[] = {  {&_swigt__p_f_size_t__p_void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_f_void__p_void[] = {  {&_swigt__p_f_void__p_void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_ino_t[] = {  {&_swigt__p_ino_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_p_char[] = {  {&_swigt__p_p_p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_security_context_t[] = {  {&_swigt__p_security_context_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_security_id[] = {  {&_swigt__p_p_security_id, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_security_id[] = {  {&_swigt__p_security_id, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
 
 static swig_cast_info *swig_cast_initial[] = {
   _swigc__p_SELboolean,
-  _swigc__p_access_vector_t,
+  _swigc__p_av_decision,
+  _swigc__p_avc_cache_stats,
+  _swigc__p_avc_entry,
+  _swigc__p_avc_entry_ref,
+  _swigc__p_avc_lock_callback,
+  _swigc__p_avc_log_callback,
+  _swigc__p_avc_memory_callback,
+  _swigc__p_avc_thread_callback,
   _swigc__p_char,
+  _swigc__p_f_p_f_void__void__p_void,
+  _swigc__p_f_p_q_const__char_v_______void,
+  _swigc__p_f_p_void__void,
+  _swigc__p_f_p_void_unsigned_short_p_char_size_t__void,
+  _swigc__p_f_size_t__p_void,
+  _swigc__p_f_void__p_void,
+  _swigc__p_ino_t,
   _swigc__p_int,
   _swigc__p_p_char,
   _swigc__p_p_p_char,
-  _swigc__p_security_context_t,
+  _swigc__p_p_security_id,
+  _swigc__p_security_id,
   _swigc__p_unsigned_int,
+  _swigc__p_unsigned_short,
 };
 
 
@@ -4479,7 +9489,7 @@
  * structures together.
  *
  * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop though that array, and handle each type individually.
+ * array. We just loop through that array, and handle each type individually.
  * First we lookup if this type has been already loaded, and if so, use the
  * loaded structure instead of the generated one. Then we have to fill in the
  * cast linked list. The cast data is initially stored in something like a
@@ -4517,32 +9527,58 @@
 #define SWIGRUNTIME_DEBUG
 #endif
 
+
 SWIGRUNTIME void
 SWIG_InitializeModule(void *clientdata) {
   size_t i;
-  swig_module_info *module_head;
-  static int init_run = 0;
+  swig_module_info *module_head, *iter;
+  int found, init;
   
   clientdata = clientdata;
   
-  if (init_run) return;
-  init_run = 1;
-  
-  /* Initialize the swig_module */
-  swig_module.type_initial = swig_type_initial;
-  swig_module.cast_initial = swig_cast_initial;
+  /* check to see if the circular list has been setup, if not, set it up */
+  if (swig_module.next==0) {
+    /* Initialize the swig_module */
+    swig_module.type_initial = swig_type_initial;
+    swig_module.cast_initial = swig_cast_initial;
+    swig_module.next = &swig_module;
+    init = 1;
+  } else {
+    init = 0;
+  }
   
   /* Try and load any already created modules */
   module_head = SWIG_GetModule(clientdata);
-  if (module_head) {
+  if (!module_head) {
+    /* This is the first module loaded for this interpreter */
+    /* so set the swig module into the interpreter */
+    SWIG_SetModule(clientdata, &swig_module);
+    module_head = &swig_module;
+  } else {
+    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+    found=0;
+    iter=module_head;
+    do {
+      if (iter==&swig_module) {
+        found=1;
+        break;
+      }
+      iter=iter->next;
+    } while (iter!= module_head);
+    
+    /* if the is found in the list, then all is done and we may leave */
+    if (found) return;
+    /* otherwise we must add out module into the list */
     swig_module.next = module_head->next;
     module_head->next = &swig_module;
-  } else {
-    /* This is the first module loaded */
-    swig_module.next = &swig_module;
-    SWIG_SetModule(clientdata, &swig_module);
   }
   
+  /* When multiple interpeters are used, a module could have already been initialized in
+       a different interpreter, but not yet have a pointer in this interpreter.
+       In this case, we do not want to continue adding types... everything should be
+       set up already */
+  if (init == 0) return;
+  
   /* Now work on filling in swig_module.types */
 #ifdef SWIGRUNTIME_DEBUG
   printf("SWIG_InitializeModule: size %d\n", swig_module.size);
@@ -4853,7 +9889,7 @@
   }
   
   SWIGINTERN PyObject *
-  SWIG_globals() {
+  SWIG_globals(void) {
     static PyObject *_SWIG_globals = 0; 
     if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
     return _SWIG_globals;
@@ -4898,11 +9934,11 @@
     swig_type_info **types_initial) {
     size_t i;
     for (i = 0; methods[i].ml_name; ++i) {
-      char *c = methods[i].ml_doc;
+      const char *c = methods[i].ml_doc;
       if (c && (c = strstr(c, "swig_ptr: "))) {
         int j;
         swig_const_info *ci = 0;
-        char *name = c + 10;
+        const char *name = c + 10;
         for (j = 0; const_table[j].type; ++j) {
           if (strncmp(const_table[j].name, name, 
               strlen(const_table[j].name)) == 0) {
@@ -4959,5 +9995,16 @@
   
   SWIG_Python_SetConstant(d, "MATCHPATHCON_BASEONLY",SWIG_From_int((int)(1)));
   SWIG_Python_SetConstant(d, "MATCHPATHCON_NOTRANS",SWIG_From_int((int)(2)));
+  SWIG_Python_SetConstant(d, "MATCHPATHCON_VALIDATE",SWIG_From_int((int)(4)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_GRANT",SWIG_From_int((int)(1)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_TRY_REVOKE",SWIG_From_int((int)(2)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_REVOKE",SWIG_From_int((int)(4)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_RESET",SWIG_From_int((int)(8)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_AUDITALLOW_ENABLE",SWIG_From_int((int)(16)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_AUDITALLOW_DISABLE",SWIG_From_int((int)(32)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_AUDITDENY_ENABLE",SWIG_From_int((int)(64)));
+  SWIG_Python_SetConstant(d, "AVC_CALLBACK_AUDITDENY_DISABLE",SWIG_From_int((int)(128)));
+  SWIG_Python_SetConstant(d, "AVC_CACHE_STATS",SWIG_From_int((int)(1)));
+  SWIG_Python_SetConstant(d, "SELINUX_DEFAULTUSER",SWIG_FromCharPtr("user_u"));
 }
 
diff --exclude-from=exclude -N -u -r nsalibselinux/src/setrans_client.c libselinux-1.33.4/src/setrans_client.c
--- nsalibselinux/src/setrans_client.c	2007-01-11 20:01:23.000000000 +0100
+++ libselinux-1.33.4/src/setrans_client.c	2010-11-16 12:16:57.640148769 +0100
@@ -201,6 +201,7 @@
 	return ret;
 }
 
+/* bug #537040
 hidden void fini_context_translations(void)
 {
 	if (cache_trans) {
@@ -210,6 +211,7 @@
 		free(prev_t2r_raw);
 	}
 }
+*/
 
 hidden int init_context_translations(void)
 {
diff --exclude-from=exclude -N -u -r nsalibselinux/src/setrans_internal.h libselinux-1.33.4/src/setrans_internal.h
--- nsalibselinux/src/setrans_internal.h	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/src/setrans_internal.h	2010-11-16 12:18:31.880400356 +0100
@@ -8,4 +8,4 @@
 #define MAX_DATA_BUF			8192
 
 extern int init_context_translations(void);
-extern void fini_context_translations(void);
+//extern void fini_context_translations(void);
diff --exclude-from=exclude -N -u -r nsalibselinux/utils/matchpathcon.c libselinux-1.33.4/utils/matchpathcon.c
--- nsalibselinux/utils/matchpathcon.c	2007-01-11 20:01:24.000000000 +0100
+++ libselinux-1.33.4/utils/matchpathcon.c	2010-07-19 19:36:19.000000000 +0200
@@ -12,7 +12,7 @@
 void usage(const char *progname)
 {
 	fprintf(stderr,
-		"usage:  %s [-N] [-n] [-f file_contexts] [-p prefix] [-V] path...\n",
+		"usage:  %s [-N] [-n] [-f file_contexts] [-p prefix] [-Vq] path...\n",
 		progname);
 	exit(1);
 }
@@ -22,9 +22,13 @@
 	char *buf;
 	int rc = matchpathcon(path, mode, &buf);
 	if (rc < 0) {
-		fprintf(stderr, "matchpathcon(%s) failed: %s\n", path,
-			strerror(errno));
-		return 1;
+		if (errno == ENOENT) {
+			buf=strdup("<<none>>");
+		} else {
+			fprintf(stderr, "matchpathcon(%s) failed: %s\n", path,
+				strerror(errno));
+			return 1;
+		}
 	}
 	if (header)
 		printf("%s\t%s\n", path, buf);
@@ -42,11 +46,12 @@
 	int verify = 0;
 	int notrans = 0;
 	int error = 0;
+	int quiet = 0;
 
 	if (argc < 2)
 		usage(argv[0]);
 
-	while ((opt = getopt(argc, argv, "Nnf:p:V")) > 0) {
+	while ((opt = getopt(argc, argv, "Nnf:p:Vq")) > 0) {
 		switch (opt) {
 		case 'n':
 			header = 0;
@@ -90,6 +95,9 @@
 				exit(1);
 			}
 			break;
+		case 'q':
+			quiet = 1;
+			break;
 		default:
 			usage(argv[0]);
 		}
@@ -97,15 +105,27 @@
 	for (i = optind; i < argc; i++) {
 		int mode = 0;
 		struct stat buf;
+		int len = strlen(argv[i]);
+		if (len > 1  && argv[i][len - 1 ] == '/') {
+			argv[i][len - 1 ] = '\0';
+		}
+
 		if (lstat(argv[i], &buf) == 0)
 			mode = buf.st_mode;
 
 		if (verify) {
-			if (selinux_file_context_verify(argv[i], 0)) {
+			if (quiet) {
+				if (selinux_file_context_verify(argv[i], mode))
+					continue;
+				else
+					exit(1);
+			}
+			if (selinux_file_context_verify(argv[i], mode)) {
 				printf("%s verified.\n", argv[i]);
 			} else {
 				security_context_t con;
 				int rc;
+				error = 1;
 				if (notrans)
 					rc = lgetfilecon_raw(argv[i], &con);
 				else
@@ -114,19 +134,17 @@
 				if (rc >= 0) {
 					printf("%s has context %s, should be ",
 					       argv[i], con);
-					error +=
-					    printmatchpathcon(argv[i], 0, mode);
+					printmatchpathcon(argv[i], 0, mode);
 					freecon(con);
 				} else {
 					printf
 					    ("actual context unknown: %s, should be ",
 					     strerror(errno));
-					error +=
-					    printmatchpathcon(argv[i], 0, mode);
+					printmatchpathcon(argv[i], 0, mode);
 				}
 			}
 		} else {
-			error += printmatchpathcon(argv[i], header, mode);
+			error |= printmatchpathcon(argv[i], header, mode);
 		}
 	}
 	matchpathcon_fini();
